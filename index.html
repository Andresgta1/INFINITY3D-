<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Infinity3D Mobile - Interfaz Ultra Compacta</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* Variables CSS para la nueva paleta de colores y estilos compactos */
        :root {
            --fondo-principal: #1a1a2e; /* Deep purple-blue, slightly lighter than image */
            --fondo-secundario: #16213e; /* Slightly darker purple-blue for panels */
            --color-acento: #e05d5d; /* Soft red/coral for highlights */
            --color-texto: #e0e0e0; /* Off-white for text */
            --color-botones: #3e497a; /* Medium blue-purple for button background */
            --color-hover: #5c679a; /* Lighter blue-purple for button hover */
            --color-borde: #283a5e; /* Darker blue-purple for borders */
            --color-sombra: rgba(0,0,0,0.4); /* General shadow color */
            --border-radius-suave: 4px; /* Even smaller rounded corners */
            --padding-base: 5px; /* Reduced base padding */
            --gap-base: 4px; /* Reduced base gap */
            --font-size-sm: 10px; /* Smaller font size for general text */
            --font-size-md: 11px; /* Medium font size for buttons/labels */
            --font-size-lg: 13px; /* Larger font size for titles */
            --font-size-xl: 16px; /* For main titles */
        }

        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100%;
            height: 100%;
            font-family: 'Inter', sans-serif; /* Fuente moderna y legible */
            background: var(--fondo-principal);
            color: var(--color-texto);
            touch-action: none; /* Deshabilita el comportamiento de desplazamiento predeterminado */
            user-select: none; /* Deshabilita la selección de texto */
            -webkit-tap-highlight-color: transparent; /* Elimina el resplandor de toque en iOS */
        }

        /* Contenedor principal con Grid para el layout */
        #main-layout {
            display: grid;
            grid-template-columns: auto 1fr auto; /* Left Sidebar, Canvas, Right Panel */
            grid-template-rows: auto 1fr auto; /* Top Bar, Main Content, Bottom Bar/Timeline */
            grid-template-areas:
                "header header header"
                "sidebar-left canvas-area properties-panel"
                "timeline timeline timeline";
            height: 100%;
            width: 100%;
        }

        /* Estilos para las barras superior e inferior */
        #barra-superior {
            grid-area: header;
            background: var(--fondo-secundario);
            display: flex;
            justify-content: space-between; /* Align logo left, buttons right */
            align-items: center;
            padding: var(--padding-base) 10px; /* Adjusted padding */
            z-index: 100;
            box-shadow: 0 1px 5px var(--color-sombra); /* Smaller shadow */
            min-height: 40px; /* Even smaller height for top bar */
        }

        #app-title {
            font-size: var(--font-size-xl);
            font-weight: 700;
            color: var(--color-acento); /* Accent color for title */
            margin-right: 15px;
        }

        #top-right-buttons {
            display: flex;
            gap: var(--gap-base);
        }
        
        #barra-inferior {
            grid-area: timeline;
            background: var(--fondo-secundario);
            display: flex;
            justify-content: center; /* Center the timeline content */
            align-items: center;
            gap: var(--gap-base);
            padding: var(--padding-base);
            z-index: 100;
            box-shadow: 0 -1px 5px var(--color-sombra); /* Smaller shadow */
            min-height: 45px; /* Even smaller height for timeline */
        }

        /* Nueva barra lateral izquierda para herramientas */
        #sidebar-left {
            grid-area: sidebar-left;
            background: var(--fondo-secundario);
            display: flex;
            flex-direction: column;
            gap: var(--gap-base);
            padding: var(--padding-base);
            box-shadow: 1px 0 5px var(--color-sombra); /* Smaller shadow */
            z-index: 90;
            width: 45px; /* Fixed width for icon sidebar */
            align-items: center;
            justify-content: flex-start;
            overflow-y: auto; /* Allow scrolling if many tools */
        }

        #sidebar-left .boton {
            width: 35px; /* Fixed width for square icon buttons */
            height: 35px; /* Fixed height for square icon buttons */
            padding: 0; /* Remove padding */
            font-size: 18px; /* Slightly smaller icon size */
        }
        #sidebar-left .boton.active {
            background: var(--color-acento);
            color: white;
        }

        /* Estilos generales de los botones */
        .boton, .boton-menu {
            background: var(--color-botones);
            color: var(--color-texto);
            border: none;
            padding: 4px 8px; /* Reduced padding */
            border-radius: var(--border-radius-suave);
            font-size: var(--font-size-md);
            cursor: pointer;
            transition: background 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 3px; /* Reduced gap */
            white-space: nowrap;
            box-shadow: 0 1px 2px rgba(0,0,0,0.2); /* Lighter shadow for buttons */
        }

        .boton:hover, .boton-menu:hover {
            background: var(--color-hover);
            box-shadow: 0 1px 3px rgba(0,0,0,0.3); /* Smaller shadow on hover */
        }

        .boton:active, .boton-menu:active {
            transform: scale(0.98);
            background: var(--color-acento);
            box-shadow: inset 0 0 2px rgba(0,0,0,0.3); /* Smaller inner shadow */
        }
        
        .boton:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background: #2a2a4a;
            box-shadow: none;
            transform: none;
        }

        /* Estilos del Canvas de renderizado */
        canvas {
            grid-area: canvas-area;
            width: 100%;
            height: 100%;
            display: block;
            background: #22223b; /* Fondo del visor */
        }

        /* Panel de Propiedades (derecho) */
        #properties-panel {
            grid-area: properties-panel;
            background: var(--fondo-secundario);
            color: var(--color-texto);
            padding: var(--padding-base);
            border-radius: var(--border-radius-suave); /* Apply to panel itself */
            box-shadow: -1px 0 5px var(--color-sombra); /* Smaller shadow */
            z-index: 90;
            width: 220px; /* Fixed width for properties panel */
            overflow-y: auto; /* Allow scrolling for content */
        }

        #properties-panel h3 {
            font-size: var(--font-size-lg);
            color: var(--color-acento);
            margin-top: 0;
            margin-bottom: 10px; /* Reduced margin */
            padding-bottom: 5px; /* Reduced padding */
            border-bottom: 1px solid var(--color-borde);
        }

        .panel-section {
            margin-bottom: 10px; /* Reduced margin */
            padding-bottom: 8px; /* Reduced padding */
            border-bottom: 1px dashed rgba(255,255,255,0.1); /* Lighter separator */
        }
        .panel-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .panel-section label {
            display: block;
            margin-bottom: 3px; /* Reduced margin */
            font-size: var(--font-size-sm);
            color: var(--color-texto);
        }

        .input-group {
            display: flex;
            align-items: center;
            gap: 3px; /* Reduced gap */
            margin-bottom: 6px; /* Reduced margin */
        }
        .input-group label {
            flex-basis: 40px; /* Fixed width for labels like 'X:', 'Y:', 'Z:' */
            margin-bottom: 0;
            text-align: right;
        }
        .input-group input[type="number"] {
            flex-grow: 1;
            background: #2a2a4a; /* Darker input background */
            border: 1px solid var(--color-borde);
            border-radius: 3px; /* Reduced border-radius */
            color: var(--color-texto);
            padding: 3px 5px; /* Reduced padding */
            font-size: var(--font-size-sm); /* Reduced font size */
            width: auto; /* Allow flex-grow to manage width */
        }

        /* Estilos para los selectores de color de luz */
        #colorPicker, #ambientLightColorPicker, #pointLightColorPicker, #directionalLightColorPicker {
            width: 100%;
            height: 25px; /* Reduced height */
            margin-top: var(--gap-base);
            border: 1px solid var(--color-borde);
            background: #1a1a2e;
            border-radius: var(--border-radius-suave);
            cursor: pointer;
        }

        /* Estilos para los nuevos botones de sub-configuración (General, Modos, Material, Outliner) */
        .config-sub-buttons {
            display: flex;
            justify-content: space-around;
            margin-bottom: 10px; /* Reduced margin */
            gap: var(--gap-base);
            border-bottom: 1px solid var(--color-borde);
            padding-bottom: 6px; /* Reduced padding */
        }

        .sub-config-button {
            flex-grow: 1;
            background: var(--color-botones);
            color: var(--color-texto);
            border: none;
            padding: 4px 8px; /* Reduced padding */
            border-radius: var(--border-radius-suave);
            font-size: var(--font-size-md);
            cursor: pointer;
            transition: background 0.2s ease, box-shadow 0.2s ease;
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }

        .sub-config-button:hover {
            background: var(--color-hover);
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }

        .sub-config-button.active {
            background: var(--color-acento);
            font-weight: 600;
            color: white;
            box-shadow: inset 0 0 2px rgba(0,0,0,0.3);
        }

        /* Estilos para las nuevas secciones de sub-configuración */
        .config-sub-section {
            display: none;
            padding-top: 6px; /* Reduced padding */
        }

        .config-sub-section.active {
            display: block;
        }

        /* Estilos de los sliders */
        input[type="range"] {
            width: 100%;
            height: 4px; /* Reduced height */
            margin-bottom: 8px; /* Reduced margin */
            background: var(--color-borde);
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px; /* Reduced size */
            height: 16px; /* Reduced size */
            border-radius: 50%;
            background: var(--color-acento);
            cursor: grab;
            border: 1px solid var(--color-texto);
            margin-top: -6px;
            box-shadow: 0 0 2px rgba(0,0,0,0.4);
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px; /* Reduced size */
            height: 16px; /* Reduced size */
            border-radius: 50%;
            background: var(--color-acento);
            cursor: grab;
            border: 1px solid var(--color-texto);
            box-shadow: 0 0 2px rgba(0,0,0,0.4);
        }
        
        hr {
            border-color: #3a3a5e;
            margin: 10px 0; /* Reduced margin */
        }

        /* Estilos de los checkboxes */
        .checkbox-container {
            display: flex;
            align-items: center;
            margin-bottom: 6px; /* Reduced margin */
            gap: 6px; /* Reduced gap */
        }

        .checkbox-container input[type="checkbox"] {
            width: 16px; /* Reduced size */
            height: 16px; /* Reduced size */
            cursor: pointer;
            border: 1px solid var(--color-borde);
            background: var(--color-botones);
            appearance: none;
            -webkit-appearance: none;
            position: relative;
            border-radius: 2px; /* Reduced border-radius */
            transition: background 0.2s ease, border-color 0.2s ease;
        }

        .checkbox-container input[type="checkbox"]:checked {
            background: var(--color-acento);
            border-color: var(--color-acento);
        }
        
        .checkbox-container input[type="checkbox"]:checked::after {
            content: '✔';
            display: block;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 10px; /* Reduced font size */
        }

        /* Etiquetas de valor para sliders */
        .slider-value-label {
            font-size: var(--font-size-sm);
            color: var(--color-acento);
            display: inline-block;
            margin-left: 4px; /* Reduced margin */
            min-width: 30px; /* Reduced min-width */
            text-align: right;
            font-weight: 600;
        }

        /* --- Estilos para Outliner/Lista de Figuras --- */
        #listaContenido {
            max-height: 250px; /* Max height for scrollable list */
            overflow-y: auto;
            border-radius: var(--border-radius-suave);
            border: 1px solid var(--color-borde);
            margin-top: 8px; /* Reduced margin */
        }

        #listaContenido h4 {
            padding: 6px 10px; /* Reduced padding */
            font-size: var(--font-size-md);
            margin: 0;
            border-bottom: 1px solid var(--color-borde);
            background: #1a1a2e;
            position: sticky;
            top: 0;
            z-index: 1;
            font-weight: 600;
        }

        .itemLista {
            padding: 6px 10px; /* Reduced padding */
            font-size: var(--font-size-md);
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #283a5e;
            cursor: pointer;
            position: relative;
            transition: background 0.1s ease;
        }
        .itemLista:last-child {
            border-bottom: none;
        }
        .itemLista:hover {
            background: #22223b;
        }
        .itemLista.seleccionado {
            background: var(--color-acento);
            font-weight: 600;
            color: white;
        }
        .itemLista.bloqueado {
            opacity: 0.7;
            cursor: not-allowed;
            background: #2a2a4a;
            color: #b0b0b0;
        }
        .itemLista.bloqueado .botones-item button {
            pointer-events: none;
            opacity: 0.4;
        }

        .itemLista .nombre-item {
            flex-grow: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            padding-right: 6px; /* Reduced padding */
        }

        .itemLista .botones-item {
            display: flex;
            gap: 2px; /* Reduced gap */
            margin-left: 6px; /* Reduced margin */
        }

        .boton-eliminar-item, .boton-renombrar-item, .boton-bloquear-item {
            background: #4a4a6a;
            color: white;
            border: none;
            border-radius: 2px; /* Reduced border-radius */
            padding: 3px 6px; /* Reduced padding */
            font-size: var(--font-size-sm);
            cursor: pointer;
            line-height: 1;
            transition: background 0.2s ease;
        }
        .boton-eliminar-item:hover {
            background: #d9534f;
        }
        .boton-renombrar-item {
            background: #4a4a6a;
        }
        .boton-renombrar-item:hover {
            background: #5cb85c;
        }
        .boton-bloquear-item {
            background: #4a4a6a;
            color: var(--color-texto);
        }
        .boton-bloquear-item.active {
            background: var(--color-acento);
            color: white;
        }
        .boton-bloquear-item:hover {
            background: #7a7a9a;
        }

        .itemLista input[type="text"] {
            background: #33334a;
            color: white;
            border: 1px solid var(--color-acento);
            padding: 3px 6px; /* Reduced padding */
            font-size: var(--font-size-md);
            border-radius: 3px;
            width: calc(100% - 12px); /* Adjusted width */
            box-sizing: border-box;
            position: absolute;
            left: 6px; /* Adjusted position */
            top: 50%;
            transform: translateY(-50%);
            display: none;
            z-index: 2;
        }

        /* Timeline specific styles */
        #timeline-controls {
            display: flex;
            align-items: center;
            gap: 8px; /* Reduced gap */
        }

        #timeline-bar {
            flex-grow: 1;
            height: 16px; /* Reduced height */
            background: #2a2a4a;
            border-radius: 3px;
            position: relative;
            cursor: pointer;
        }

        #timeline-playhead {
            position: absolute;
            top: 0;
            left: 0;
            width: 2px;
            height: 100%;
            background: var(--color-acento);
            pointer-events: none;
        }

        .timeline-marker {
            position: absolute;
            top: 0;
            width: 1px;
            height: 100%;
            background: rgba(255,255,255,0.2);
        }
        .timeline-marker span {
            position: absolute;
            top: 18px; /* Adjusted position */
            left: -8px; /* Adjusted position */
            font-size: 9px; /* Smaller font size */
            color: #aaa;
            width: 16px; /* Adjusted width */
            text-align: center;
        }

        /* Toast/Notificación */
        #toast {
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            bottom: 55px; /* Adjusted position to be above timeline */
            background: rgba(30, 30, 50, 0.95);
            color: var(--color-texto);
            padding: 8px 12px; /* Reduced padding */
            border-radius: var(--border-radius-suave);
            font-size: var(--font-size-md);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
            z-index: 1000;
            white-space: nowrap;
            border: 1px solid var(--color-borde);
            box-shadow: 0 1px 8px rgba(0,0,0,0.5); /* Reduced shadow */
        }
        #toast.mostrar {
            opacity: 1;
            visibility: visible;
        }

        /* Overlays y diálogos de confirmación */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 500;
            display: none;
        }

        .dialogo {
            background: var(--fondo-secundario);
            color: var(--color-texto);
            padding: 15px; /* Reduced padding */
            border-radius: var(--border-radius-suave);
            text-align: center;
            box-shadow: 0 4px 15px var(--color-sombra); /* Reduced shadow */
            max-width: 80%; /* Adjusted max-width */
            border: 1px solid var(--color-borde);
        }

        .dialogo h3 {
            margin-bottom: 10px; /* Reduced margin */
            font-size: 16px; /* Reduced font size */
            color: var(--color-acento);
            font-weight: 700;
        }

        .dialogo p {
            margin-bottom: 15px; /* Reduced margin */
            font-size: var(--font-size-md);
        }

        .dialogo-botones button {
            background: var(--color-acento);
            color: white;
            border: none;
            padding: 6px 12px; /* Reduced padding */
            border-radius: 3px; /* Reduced border-radius */
            font-size: var(--font-size-md);
            cursor: pointer;
            margin: 0 6px; /* Reduced margin */
            transition: background 0.2s ease, transform 0.1s ease;
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }
        .dialogo-botones button:hover {
            background: #c04a4a;
        }
        .dialogo-botones button:last-child {
            background: #5a6268;
        }
        .dialogo-botones button:last-child:hover {
            background: #4a5055;
        }

        /* Estilos para los modos de transformación y visualización */
        .modo-transformacion, .modo-visualizacion {
            display: flex;
            justify-content: space-around;
            margin-top: 10px; /* Reduced margin */
            gap: var(--gap-base);
        }

        .modo-transformacion button, .modo-visualizacion button {
            flex-grow: 1;
            padding: 4px 8px; /* Reduced padding */
            border-radius: var(--border-radius-suave);
            font-size: var(--font-size-md);
            background: var(--color-botones);
            color: var(--color-texto);
            border: none;
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }
        .modo-transformacion button.active, .modo-visualizacion button.active {
            background: var(--color-acento);
            font-weight: 600;
            color: white;
            box-shadow: inset 0 0 2px rgba(0,0,0,0.3);
        }
    </style>
</head>
<body>
    <div id="main-layout">
        <!-- Top Bar -->
        <div id="barra-superior">
            <div id="app-title">Infinity3D</div>
            <div id="top-right-buttons">
                <button class="boton" onclick="reiniciarEscena()">🔄 Nuevo</button>
                <button class="boton" onclick="guardarEscena()">💾 Guardar</button>
                <button class="boton" onclick="cargarEscena()">📂 Cargar</button>
                <button class="boton" onclick="activarPantallaCompleta()">⛶ Fullscreen</button>
                <button class="boton" onclick="deshacerAccion()" id="btnDeshacer">↩ Deshacer</button>
                <button class="boton" onclick="rehacerAccion()" id="btnRehacer">↪ Rehacer</button>
            </div>
        </div>

        <!-- Left Sidebar for Tools -->
        <div id="sidebar-left">
            <button class="boton active" id="tool-select" onclick="setTool('select')">👆</button>
            <button class="boton" id="tool-move" onclick="establecerModoTransformacion('trasladar')">↔️</button>
            <button class="boton" id="tool-rotate" onclick="establecerModoTransformacion('rotar')">🔄</button>
            <button class="boton" id="tool-scale" onclick="establecerModoTransformacion('escalar')">↖️↘️</button>
            <hr style="width: 80%; border-color: #3a3a5e;">
            <button class="boton" onclick="agregarFigura('cubo')">📦</button>
            <button class="boton" onclick="agregarFigura('esfera')">🌐</button>
            <button class="boton" onclick="agregarFigura('cono')">🔺</button>
            <button class="boton" onclick="agregarFigura('cilindro')"> cylindrical_hose</button>
            <button class="boton" onclick="agregarFigura('toroide')">🍩</button>
            <button class="boton" onclick="agregarFigura('plano')">🔲</button>
            <button class="boton" onclick="agregarFigura('capsula')">💊</button>
            <button class="boton" onclick="agregarLuzPunto()">💡</button>
            <hr style="width: 80%; border-color: #3a3a5e;">
            <button class="boton" onclick="duplicarFigura()">📋</button>
            <button class="boton" onclick="agruparObjetos()">🔗</button>
            <button class="boton" onclick="desagruparObjetos()">💔</button>
            <button class="boton" onclick="resetearTransformacion()">♻️</button>
            <button class="boton" onclick="abrirImportadorModelo()">📥</button>
            <button class="boton" onclick="abrirImportadorTextura()">🏞️</button>
            <button class="boton" onclick="centrarFigura()">🎯</button>
            <button class="boton" onclick="exportarImagen()">🖼️</button>
            <button class="boton" onclick="exportarVideo()">🎥</button>
        </div>

        <!-- Main Canvas Area -->
        <canvas id="renderCanvas"></canvas>

        <!-- Right Properties Panel -->
        <div id="properties-panel">
            <!-- Botones para alternar entre sub-secciones de configuración -->
            <div class="config-sub-buttons">
                <button class="sub-config-button active" data-target="transformConfig">Transformación</button>
                <button class="sub-config-button" data-target="objectConfig">Objeto</button>
                <button class="sub-config-button" data-target="sceneConfig">Escena</button>
                <button class="sub-config-button" data-target="outlinerConfig">Outliner</button>
            </div>

            <!-- Sección de Transformación -->
            <div id="transformConfig" class="config-sub-section active">
                <h3>Transformación</h3>
                <div class="panel-section">
                    <label>Ubicación:</label>
                    <div class="input-group">
                        <label>X:</label><input type="number" id="posX" step="0.01">
                        <label>Y:</label><input type="number" id="posY" step="0.01">
                        <label>Z:</label><input type="number" id="posZ" step="0.01">
                    </div>
                </div>
                <div class="panel-section">
                    <label>Rotación (Euler):</label>
                    <div class="input-group">
                        <label>X:</label><input type="number" id="rotX" step="0.01">
                        <label>Y:</label><input type="number" id="rotY" step="0.01">
                        <label>Z:</label><input type="number" id="rotZ" step="0.01">
                    </div>
                </div>
                <div class="panel-section">
                    <label>Escala:</label>
                    <div class="input-group">
                        <label>X:</label><input type="number" id="scaleX" step="0.01">
                        <label>Y:</label><input type="number" id="scaleY" step="0.01">
                        <label>Z:</label><input type="number" id="scaleZ" step="0.01">
                    </div>
                </div>
            </div>

            <!-- Sección de Configuración de Objeto (Material/Luz) -->
            <div id="objectConfig" class="config-sub-section">
                <h3>Propiedades del Objeto</h3>
                <div id="object-specific-props">
                    <!-- Dynamic content based on selected object type -->
                    <p style="text-align: center; color: #aaa; font-size: var(--font-size-sm);">Selecciona un objeto para ver sus propiedades.</p>
                </div>
            </div>

            <!-- Sección de Configuración de Escena -->
            <div id="sceneConfig" class="config-sub-section">
                <h3>Configuración de Escena</h3>
                <div class="panel-section">
                    <label>⚙️ Vel. Movimiento:</label>
                    <input type="range" id="velocidadSlider" min="0.01" max="0.2" step="0.01" value="0.05">
                    <span id="velocidadLabel" class="slider-value-label">0.05</span>
                </div>
                <div class="panel-section">
                    <label>⚡ Vel. Animación:</label>
                    <input type="range" id="animSpeedSlider" min="100" max="2000" step="50" value="700">
                    <span id="animSpeedLabel" class="slider-value-label">700 ms/frame</span>
                </div>
                <div class="panel-section">
                    <label>💡 Luz Ambiental (Intensidad):</label>
                    <input type="range" id="ambientLightIntensitySlider" min="0" max="2" step="0.01" value="0.8">
                    <span id="ambientLightIntensityLabel" class="slider-value-label">0.8</span>
                    <label>💡 Luz Ambiental (Color):</label>
                    <input type="color" id="ambientLightColorPicker" value="#ffffff">
                </div>
                <div class="panel-section">
                    <label>💡 Luz Direccional (Intensidad):</label>
                    <input type="range" id="directionalLightIntensitySlider" min="0" max="2" step="0.01" value="0.6">
                    <span id="directionalLightIntensityLabel" class="slider-value-label">0.6</span>
                    <label>💡 Luz Direccional (Color):</label>
                    <input type="color" id="directionalLightColorPicker" value="#ffffff">
                </div>
                <div class="panel-section">
                    <div class="checkbox-container">
                        <label for="skyboxCheckbox">🏞️ Skybox:</label>
                        <input type="checkbox" id="skyboxCheckbox" checked onchange="toggleSkybox(this.checked)">
                    </div>
                </div>
                <div class="panel-section">
                    <label>🎚 Modo Transformación:</label>
                    <div class="modo-transformacion">
                        <button id="btnModoTrasladar" onclick="establecerModoTransformacion('trasladar')" class="active">Mover</button>
                        <button id="btnModoRotar" onclick="establecerModoTransformacion('rotar')">Rotar</button>
                        <button id="btnModoEscalar" onclick="establecerModoTransformacion('escalar')">Escalar</button>
                    </div>
                </div>
                <div class="panel-section">
                    <label>👁️ Modo Visualización:</label>
                    <div class="modo-visualizacion">
                        <button id="btnModoNormal" onclick="establecerModoVisualizacion('normal')" class="active">Normal</button>
                        <button id="btnModoWireframe" onclick="establecerModoVisualizacion('wireframe')">Alambre</button>
                        <button id="btnModoBoundingBox" onclick="establecerModoVisualizacion('bbox')">Caja Delim.</button>
                    </div>
                </div>
                <div class="panel-section">
                    <div class="checkbox-container">
                        <label for="riggingModeCheckbox">🦴 Rigging Mode:</label>
                        <input type="checkbox" id="riggingModeCheckbox" onchange="toggleRiggingMode(this.checked)">
                    </div>
                    <div class="checkbox-container">
                        <label for="axesHelperCheckbox">📏 Mostrar Ejes:</label>
                        <input type="checkbox" id="axesHelperCheckbox" checked onchange="toggleAxesHelper(this.checked)">
                    </div>
                    <div class="checkbox-container">
                        <label for="gridHelperCheckbox">🌐 Mostrar Cuadrícula:</label>
                        <input type="checkbox" id="gridHelperCheckbox" checked onchange="toggleGridHelper(this.checked)">
                    </div>
                </div>
            </div>

            <!-- Sección de Outliner -->
            <div id="outlinerConfig" class="config-sub-section">
                <h3>Outliner</h3>
                <div id="listaContenido"></div>
            </div>
        </div>

        <!-- Bottom Timeline Bar -->
        <div id="barra-inferior">
            <button class="boton" onclick="reproducirAnimacion()">▶</button>
            <button class="boton" onclick="agregarFrame()">+ Frame</button>
            <div id="timeline-controls">
                <div id="timeline-bar">
                    <div id="timeline-playhead"></div>
                    <!-- Markers for timeline -->
                    <div class="timeline-marker" style="left: 0%;"><span>0</span></div>
                    <div class="timeline-marker" style="left: 20%;"><span>20</span></div>
                    <div class="timeline-marker" style="left: 40%;"><span>40</span></div>
                    <div class="timeline-marker" style="left: 60%;"><span>60</span></div>
                    <div class="timeline-marker" style="left: 80%;"><span>80</span></div>
                    <div class="timeline-marker" style="left: 100%;"><span>100</span></div>
                </div>
            </div>
        </div>
    </div> 
    
    <!-- Toast/Notificación -->
    <div id="toast"></div>

    <!-- Diálogo de Confirmación -->
    <div id="dialogoConfirmacion" class="overlay">
        <div class="dialogo">
            <h3 id="dialogoTitulo"></h3>
            <p id="dialogoMensaje"></p>
            <div class="dialogo-botones">
                <button id="btnDialogoSi">Sí</button>
                <button id="btnDialogoNo">No</button>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/loaders/CubeTextureLoader.js"></script>
    <script>
        // Inicialización de THREE.js
        const escena = new THREE.Scene();
        const camara = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const render = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true, canvas: document.getElementById('renderCanvas') });

        const controls = new THREE.OrbitControls(camara, render.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = true;
        controls.enablePan = true;
        controls.minDistance = 2;
        controls.maxDistance = 100;
        controls.target.set(0, 1, 0);

        // Luz Ambiental
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        escena.add(ambientLight);
        // Luz direccional ya existente
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
        directionalLight.position.set(5, 10, 7.5).normalize();
        escena.add(directionalLight);

        // Axes Helper (Ejes)
        const axesHelper = new THREE.AxesHelper(5); // Size of the axes
        axesHelper.visible = true; // Initially visible
        escena.add(axesHelper);

        // Grid Helper (Cuadrícula)
        const gridHelper = new THREE.GridHelper(10, 10);
        gridHelper.visible = true; // Initially visible
        escena.add(gridHelper);

        // Skybox
        let skyboxMesh = null;
        let skyboxActivo = true; // Estado inicial del skybox

        function cargarSkybox(enable = true) {
            if (skyboxMesh) {
                escena.remove(skyboxMesh);
                skyboxMesh.geometry.dispose();
                skyboxMesh.material.dispose();
                skyboxMesh = null;
                escena.background = null; // Quita el fondo de la escena
            }

            if (!enable) {
                skyboxActivo = false;
                return;
            }

            skyboxActivo = true;
            const loader = new THREE.CubeTextureLoader();
            const texturePaths = [
                'https://threejs.org/examples/textures/cube/Bridge2/posx.jpg',
                'https://threejs.org/examples/textures/cube/Bridge2/negx.jpg',
                'https://threejs.org/examples/textures/cube/Bridge2/posy.jpg',
                'https://threejs.org/examples/textures/cube/Bridge2/negy.jpg',
                'https://threejs.org/examples/textures/cube/Bridge2/posz.jpg',
                'https://threejs.org/examples/textures/cube/Bridge2/negz.jpg'
            ];

            loader.load(texturePaths, (texture) => {
                escena.background = texture;
                mostrarToast("🏞️ Skybox cargado.");
            }, undefined, (err) => {
                console.error('Error al cargar skybox:', err);
                mostrarToast("❌ Error al cargar Skybox.");
                skyboxCheckbox.checked = false; // Desactivar si falla
                skyboxActivo = false;
                escena.background = null; // Asegurarse de que no haya un fondo roto
            });
        }
        cargarSkybox(true); // Cargar skybox por defecto al inicio

        function toggleSkybox(checked) {
            cargarSkybox(checked);
            if (!checked) {
                escena.background = null;
            }
            mostrarToast(`Skybox: ${checked ? 'Activado' : 'Desactivado'}`);
            registrarAccion({ type: 'skybox', newState: checked }); // Registrar para Undo/Redo
        }


        function ajustarCanvasSize() {
            // Con el nuevo layout de grid, el canvas ocupa el espacio automáticamente.
            // No necesitamos calcular alturas de barras.
            // Simplemente asegurarse de que el renderizador se ajuste al tamaño del canvas.
            const canvasElement = document.getElementById('renderCanvas');
            render.setSize(canvasElement.clientWidth, canvasElement.clientHeight);
            camara.aspect = canvasElement.clientWidth / canvasElement.clientHeight;
            camara.updateProjectionMatrix();
        }

        window.addEventListener("resize", ajustarCanvasSize);
        window.addEventListener("load", ajustarCanvasSize);
        ajustarCanvasSize();

        camara.position.set(0, 4, 8);

        const objetos = [];
        const objetosSeleccionadosMultiples = [];
        const contador = { cubo: 0, esfera: 0, cono: 0, cilindro: 0, toroide: 0, plano: 0, capsula: 0, modelo: 0, luzPunto: 0, grupo: 0 };
        const raycaster = new THREE.Raycaster();
        const puntero = new THREE.Vector2();
        let previousTouchPos = new THREE.Vector2();

        let objetoSeleccionado = null;
        let gizmos = [];
        let modoTransformacion = 'select'; // Default to select mode
        let modoVisualizacion = 'normal';

        let riggingModeActivo = false;

        // UI Elements
        const propertiesPanel = document.getElementById("properties-panel");
        const objectSpecificProps = document.getElementById("object-specific-props");

        // Transformation inputs
        const posXInput = document.getElementById("posX");
        const posYInput = document.getElementById("posY");
        const posZInput = document.getElementById("posZ");
        const rotXInput = document.getElementById("rotX");
        const rotYInput = document.getElementById("rotY");
        const rotZInput = document.getElementById("rotZ");
        const scaleXInput = document.getElementById("scaleX");
        const scaleYInput = document.getElementById("scaleY");
        const scaleZInput = document.getElementById("scaleZ");

        // Config controls
        const slider = document.getElementById("velocidadSlider");
        const velLabel = document.getElementById("velocidadLabel");
        const animSpeedSlider = document.getElementById("animSpeedSlider");
        const animSpeedLabel = document.getElementById("animSpeedLabel");
        const ambientLightIntensitySlider = document.getElementById("ambientLightIntensitySlider");
        const ambientLightIntensityLabel = document.getElementById("ambientLightIntensityLabel");
        const ambientLightColorPicker = document.getElementById("ambientLightColorPicker");
        const skyboxCheckbox = document.getElementById("skyboxCheckbox");
        const directionalLightIntensitySlider = document.getElementById("directionalLightIntensitySlider");
        const directionalLightIntensityLabel = document.getElementById("directionalLightIntensityLabel");
        const directionalLightColorPicker = document.getElementById("directionalLightColorPicker");

        // Axes and Grid Helpers checkboxes
        const axesHelperCheckbox = document.getElementById("axesHelperCheckbox");
        const gridHelperCheckbox = document.getElementById("gridHelperCheckbox");
        const riggingModeCheckbox = document.getElementById("riggingModeCheckbox");

        // Outliner
        const listaContenido = document.getElementById("listaContenido");
        const toast = document.getElementById("toast");
        
        // Timeline
        const timelinePlayhead = document.getElementById("timeline-playhead");


        // Elementos para la sub-configuración (Transformación, Objeto, Escena, Outliner)
        const subConfigButtons = document.querySelectorAll('.sub-config-button');
        const subConfigSections = document.querySelectorAll('.config-sub-section');

        let velocidadMovimiento = parseFloat(slider.value);
        let duracionPorFrame = parseInt(animSpeedSlider.value);

        slider.addEventListener("input", () => {
            velocidadMovimiento = parseFloat(slider.value);
            velLabel.textContent = velocidadMovimiento.toFixed(2);
        });

        animSpeedSlider.addEventListener("input", () => {
            duracionPorFrame = parseInt(animSpeedSlider.value);
            animSpeedLabel.textContent = `${duracionPorFrame} ms/frame`;
        });

        ambientLightIntensitySlider.addEventListener("input", () => {
            const oldIntensity = ambientLight.intensity;
            ambientLight.intensity = parseFloat(ambientLightIntensitySlider.value);
            ambientLightIntensityLabel.textContent = ambientLight.intensity.toFixed(2);
            registrarAccion({ type: 'ambientIntensity', oldIntensity: oldIntensity, newIntensity: ambientLight.intensity });
        });

        ambientLightColorPicker.addEventListener("input", () => {
            const oldColor = ambientLight.color.getHex();
            ambientLight.color.set(ambientLightColorPicker.value);
            registrarAccion({ type: 'ambientColor', oldColor: oldColor, newColor: ambientLight.color.getHex() });
        });

        directionalLightIntensitySlider.addEventListener("input", () => {
            const oldIntensity = directionalLight.intensity;
            directionalLight.intensity = parseFloat(directionalLightIntensitySlider.value);
            directionalLightIntensityLabel.textContent = directionalLight.intensity.toFixed(2);
            registrarAccion({ type: 'directionalIntensity', oldIntensity: oldIntensity, newIntensity: directionalLight.intensity });
        });

        directionalLightColorPicker.addEventListener("input", () => {
            const oldColor = directionalLight.color.getHex();
            directionalLight.color.set(directionalLightColorPicker.value);
            registrarAccion({ type: 'directionalColor', oldColor: oldColor, newColor: directionalLight.color.getHex() });
        });

        // Transformation input listeners
        function setupTransformInputListeners() {
            const inputs = [
                { element: posXInput, prop: 'position', axis: 'x' },
                { element: posYInput, prop: 'position', axis: 'y' },
                { element: posZInput, prop: 'position', axis: 'z' },
                { element: rotXInput, prop: 'rotation', axis: 'x' },
                { element: rotYInput, prop: 'rotation', axis: 'y' },
                { element: rotZInput, prop: 'rotation', axis: 'z' },
                { element: scaleXInput, prop: 'scale', axis: 'x' },
                { element: scaleYInput, prop: 'scale', axis: 'y' },
                { element: scaleZInput, prop: 'scale', axis: 'z' }
            ];

            inputs.forEach(({ element, prop, axis }) => {
                if (element) {
                    element.onchange = () => {
                        if (objetoSeleccionado && !objetoSeleccionado.userData.isLocked) {
                            const oldValue = objetoSeleccionado[prop][axis];
                            let newValue = parseFloat(element.value);
                            if (prop === 'rotation') {
                                newValue = THREE.MathUtils.degToRad(newValue); // Convert degrees to radians
                            }
                            if (isNaN(newValue)) {
                                element.value = prop === 'scale' ? 1 : 0; // Reset to default if invalid
                                newValue = prop === 'scale' ? 1 : 0;
                            }
                            
                            const oldState = {
                                position: objetoSeleccionado.position.clone(),
                                rotation: objetoSeleccionado.rotation.clone(),
                                scale: objetoSeleccionado.scale.clone()
                            };

                            objetoSeleccionado[prop][axis] = newValue;
                            
                            const newState = {
                                position: objetoSeleccionado.position.clone(),
                                rotation: objetoSeleccionado.rotation.clone(),
                                scale: objetoSeleccionado.scale.clone()
                            };
                            registrarAccion({ type: 'transform', objectId: objetoSeleccionado.uuid, oldState: oldState, newState: newState });
                            crearGizmos(objetoSeleccionado); // Update gizmos if transformation changes
                        }
                    };
                }
            });
        }
        setupTransformInputListeners();


        // Axes and Grid Helper toggles
        axesHelperCheckbox.addEventListener("change", (e) => {
            const oldVisibility = axesHelper.visible;
            axesHelper.visible = e.target.checked;
            mostrarToast(`Ejes: ${axesHelper.visible ? 'Visible' : 'Oculto'}`);
            registrarAccion({ type: 'axesHelper', newState: axesHelper.visible, oldState: oldVisibility });
        });

        gridHelperCheckbox.addEventListener("change", (e) => {
            const oldVisibility = gridHelper.visible;
            gridHelper.visible = e.target.checked;
            mostrarToast(`Cuadrícula: ${gridHelper.visible ? 'Visible' : 'Oculto'}`);
            registrarAccion({ type: 'gridHelper', newState: gridHelper.visible, oldState: oldVisibility });
        });


        const dialogoConfirmacion = document.getElementById('dialogoConfirmacion');
        const dialogoTitulo = document.getElementById('dialogoTitulo');
        const dialogoMensaje = document.getElementById('dialogoMensaje');
        const btnDialogoSi = document.getElementById('btnDialogoSi');
        const btnDialogoNo = document.getElementById('btnDialogoNo');
        let accionConfirmacion = null;

        let puntoInterseccionInicial3D = new THREE.Vector3();

        // --- Funciones de Interfaz de Usuario ---

        function mostrarToast(mensaje, duracion = 3000) {
            toast.textContent = mensaje;
            toast.classList.add("mostrar");
            setTimeout(() => {
                toast.classList.remove("mostrar");
            }, duracion);
        }

        // Function to set the active tool button in the left sidebar
        function setTool(toolId) {
            document.querySelectorAll('#sidebar-left .boton').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(`tool-${toolId}`).classList.add('active');
            // If the tool is a transformation tool, update the transformation mode
            if (['move', 'rotate', 'scale'].includes(toolId)) {
                establecerModoTransformacion(toolId === 'move' ? 'trasladar' : toolId);
            } else {
                // For other tools, ensure gizmos are removed if not a transformation tool
                eliminarGizmos();
                // We don't need to change modoTransformacion for non-transform tools
                // but we might want to disable OrbitControls interaction if a specific tool requires it
            }
            mostrarToast(`Herramienta: ${toolId.charAt(0).toUpperCase() + toolId.slice(1)}`);
        }

        // Función para mostrar las sub-secciones de configuración (Transformación, Objeto, Escena, Outliner)
        function showSubConfigSection(targetId) {
            subConfigSections.forEach(section => {
                if (section.id === targetId) {
                    section.classList.add('active');
                } else {
                    section.classList.remove('active');
                }
            });

            subConfigButtons.forEach(button => {
                if (button.dataset.target === targetId) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });
            if (targetId === 'outlinerConfig') {
                actualizarLista();
            }
        }

        // Añadir EventListeners a los nuevos botones de sub-configuración
        subConfigButtons.forEach(button => {
            button.addEventListener('click', () => {
                const targetId = button.dataset.target;
                showSubConfigSection(targetId);
            });
        });
        // Asegurarse de que la sección General esté activa al inicio
        showSubConfigSection('transformConfig');


        function updateObjectPropertiesPanel(obj) {
            objectSpecificProps.innerHTML = ''; // Clear previous content

            if (!obj) {
                objectSpecificProps.innerHTML = '<p style="text-align: center; color: #aaa; font-size: var(--font-size-sm);">Selecciona un objeto para ver sus propiedades.</p>';
                return;
            }

            let htmlContent = '';

            // Common properties (Color for meshes, Light properties for lights)
            if (obj.isMesh && obj.material) {
                htmlContent += `
                    <div class="panel-section">
                        <label>🎨 Color Objeto:</label>
                        <input type="color" id="colorPicker" value="#${obj.material.color ? obj.material.color.getHexString() : 'ffffff'}" />
                    </div>
                    <div class="panel-section">
                        <label>✨ Rugosidad (Roughness):</label>
                        <input type="range" id="roughnessSlider" min="0" max="1" step="0.01" value="${obj.material.roughness !== undefined ? obj.material.roughness : 0.5}">
                        <span id="roughnessLabel" class="slider-value-label">${(obj.material.roughness !== undefined ? obj.material.roughness : 0.5).toFixed(2)}</span>
                    </div>
                    <div class="panel-section">
                        <label>✨ Metalicidad (Metalness):</label>
                        <input type="range" id="metalnessSlider" min="0" max="1" step="0.01" value="${obj.material.metalness !== undefined ? obj.material.metalness : 0.0}">
                        <span id="metalnessLabel" class="slider-value-label">${(obj.material.metalness !== undefined ? obj.material.metalness : 0.0).toFixed(2)}</span>
                    </div>
                    <div class="panel-section">
                        <label>✨ Opacidad (Opacity):</label>
                        <input type="range" id="opacitySlider" min="0" max="1" step="0.01" value="${obj.material.opacity !== undefined ? obj.material.opacity : 1.0}">
                        <span id="opacityLabel" class="slider-value-label">${(obj.material.opacity !== undefined ? obj.material.opacity : 1.0).toFixed(2)}</span>
                        <div class="checkbox-container">
                            <label for="transparentCheckbox">👻 Transparente:</label>
                            <input type="checkbox" id="transparentCheckbox" ${obj.material.transparent ? 'checked' : ''}>
                        </div>
                    </div>
                `;
            } else if (obj.userData.tipo === 'luzPunto') {
                htmlContent += `
                    <div class="panel-section">
                        <label>💡 Luz de Punto (Intensidad):</label>
                        <input type="range" id="pointLightIntensitySlider" min="0" max="5" step="0.1" value="${obj.intensity}">
                        <span id="pointLightIntensityLabel" class="slider-value-label">${obj.intensity.toFixed(1)}</span>
                    </div>
                    <div class="panel-section">
                        <label>💡 Luz de Punto (Distancia):</label>
                        <input type="range" id="pointLightDistanceSlider" min="0" max="20" step="0.5" value="${obj.distance}">
                        <span id="pointLightDistanceLabel" class="slider-value-label">${obj.distance.toFixed(1)} ${obj.distance === 0 ? " (infinita)" : ""}</span>
                    </div>
                    <div class="panel-section">
                        <label>💡 Luz de Punto (Color):</label>
                        <input type="color" id="pointLightColorPicker" value="#${obj.color.getHexString()}">
                    </div>
                `;
            } else if (obj.userData.tipo === 'grupo') {
                htmlContent += `
                    <p style="text-align: center; color: #aaa; font-size: var(--font-size-sm);">Este es un grupo. Sus propiedades se controlan a través de los objetos individuales.</p>
                `;
            } else if (obj.userData.tipo === 'modelo') {
                htmlContent += `
                    <div class="panel-section">
                        <label>🎨 Color Objeto:</label>
                        <input type="color" id="colorPicker" value="#${obj.userData.lastColor ? new THREE.Color(obj.userData.lastColor).getHexString() : 'ffffff'}" />
                    </div>
                    <div class="panel-section">
                        <p style="font-size: var(--font-size-sm); color: #aaa;">Las propiedades de material avanzadas pueden no ser aplicables a todos los modelos importados.</p>
                    </div>
                `;
            }

            objectSpecificProps.innerHTML = htmlContent;
            setupDynamicObjectPropListeners(obj);
        }

        function setupDynamicObjectPropListeners(obj) {
            // Color Picker
            const colorPicker = document.getElementById("colorPicker");
            if (colorPicker) {
                colorPicker.oninput = () => {
                    if (obj.isMesh && obj.material) {
                        const oldColor = obj.material.color.getHex();
                        obj.material.color.set(colorPicker.value);
                        const newColor = obj.material.color.getHex();
                        if (oldColor !== newColor) {
                            registrarAccion({ type: 'color', objectId: obj.uuid, oldColor: oldColor, newColor: newColor });
                        }
                    } else if (obj.userData.tipo === 'modelo') {
                        const oldColor = obj.userData.lastColor;
                        const newColor = new THREE.Color(colorPicker.value).getHex();
                        obj.traverse((child) => {
                            if (child.isMesh && child.material) {
                                child.material.color.set(colorPicker.value);
                            }
                        });
                        obj.userData.lastColor = newColor;
                        registrarAccion({ type: 'color', objectId: obj.uuid, oldColor: oldColor, newColor: newColor });
                    }
                };
            }

            // Material properties listeners (Roughness, Metalness, Opacity, Transparent)
            const roughnessSlider = document.getElementById("roughnessSlider");
            const roughnessLabel = document.getElementById("roughnessLabel");
            const metalnessSlider = document.getElementById("metalnessSlider");
            const metalnessLabel = document.getElementById("metalnessLabel");
            const opacitySlider = document.getElementById("opacitySlider");
            const opacityLabel = document.getElementById("opacityLabel");
            const transparentCheckbox = document.getElementById("transparentCheckbox");

            if (roughnessSlider) {
                roughnessSlider.addEventListener("input", () => {
                    if (obj.isMesh && obj.material instanceof THREE.MeshStandardMaterial) {
                        const oldRoughness = obj.material.roughness;
                        obj.material.roughness = parseFloat(roughnessSlider.value);
                        roughnessLabel.textContent = obj.material.roughness.toFixed(2);
                        registrarAccion({ type: 'materialProp', objectId: obj.uuid, prop: 'roughness', oldValue: oldRoughness, newValue: obj.material.roughness });
                    }
                });
            }
            if (metalnessSlider) {
                metalnessSlider.addEventListener("input", () => {
                    if (obj.isMesh && obj.material instanceof THREE.MeshStandardMaterial) {
                        const oldMetalness = obj.material.metalness;
                        obj.material.metalness = parseFloat(metalnessSlider.value);
                        metalnessLabel.textContent = obj.material.metalness.toFixed(2);
                        registrarAccion({ type: 'materialProp', objectId: obj.uuid, prop: 'metalness', oldValue: oldMetalness, newValue: obj.material.metalness });
                    }
                });
            }
            if (opacitySlider) {
                opacitySlider.addEventListener("input", () => {
                    if (obj.isMesh && obj.material) {
                        const oldOpacity = obj.material.opacity;
                        obj.material.opacity = parseFloat(opacitySlider.value);
                        opacityLabel.textContent = obj.material.opacity.toFixed(2);
                        if (obj.material.opacity < 1 && !obj.material.transparent) {
                            obj.material.transparent = true;
                            if (transparentCheckbox) transparentCheckbox.checked = true;
                        } else if (obj.material.opacity === 1 && obj.material.transparent && transparentCheckbox && !transparentCheckbox.checked) {
                            obj.material.transparent = false;
                        }
                        obj.material.needsUpdate = true;
                        registrarAccion({ type: 'materialProp', objectId: obj.uuid, prop: 'opacity', oldValue: oldOpacity, newValue: obj.material.opacity });
                    }
                });
            }
            if (transparentCheckbox) {
                transparentCheckbox.addEventListener("change", (e) => {
                    if (obj.isMesh && obj.material) {
                        const oldTransparent = obj.material.transparent;
                        obj.material.transparent = e.target.checked;
                        if (e.target.checked && obj.material.opacity === 1) {
                            mostrarToast("Ajusta la opacidad para ver la transparencia.");
                        } else if (!e.target.checked && obj.material.opacity < 1) {
                            obj.material.opacity = 1;
                            if (opacitySlider) opacitySlider.value = 1;
                            if (opacityLabel) opacityLabel.textContent = "1.00";
                        }
                        obj.material.needsUpdate = true;
                        registrarAccion({ type: 'materialProp', objectId: obj.uuid, prop: 'transparent', oldValue: oldTransparent, newValue: obj.material.transparent });
                    }
                });
            }

            // Point Light properties listeners
            const pointLightIntensitySlider = document.getElementById("pointLightIntensitySlider");
            const pointLightIntensityLabel = document.getElementById("pointLightIntensityLabel");
            const pointLightDistanceSlider = document.getElementById("pointLightDistanceSlider");
            const pointLightDistanceLabel = document.getElementById("pointLightDistanceLabel");
            const pointLightColorPicker = document.getElementById("pointLightColorPicker");

            if (pointLightIntensitySlider) {
                pointLightIntensitySlider.addEventListener("input", () => {
                    if (obj.userData.tipo === 'luzPunto') {
                        const oldIntensity = obj.intensity;
                        obj.intensity = parseFloat(pointLightIntensitySlider.value);
                        pointLightIntensityLabel.textContent = obj.intensity.toFixed(1);
                        registrarAccion({ type: 'lightIntensity', objectId: obj.uuid, oldIntensity: oldIntensity, newIntensity: obj.intensity });
                    }
                });
            }
            if (pointLightDistanceSlider) {
                pointLightDistanceSlider.addEventListener("input", () => {
                    if (obj.userData.tipo === 'luzPunto') {
                        const oldDistance = obj.distance;
                        obj.distance = parseFloat(pointLightDistanceSlider.value);
                        pointLightDistanceLabel.textContent = obj.distance.toFixed(1) + (obj.distance === 0 ? " (infinita)" : "");
                        registrarAccion({ type: 'lightDistance', objectId: obj.uuid, oldDistance: oldDistance, newDistance: obj.distance });
                    }
                });
            }
            if (pointLightColorPicker) {
                pointLightColorPicker.addEventListener("input", () => {
                    if (obj.userData.tipo === 'luzPunto') {
                        const oldColor = obj.color.getHex();
                        obj.color.set(pointLightColorPicker.value);
                        const helper = obj.children.find(c => c.name.startsWith(`Helper `));
                        if (helper && helper.material) {
                            helper.material.color.set(obj.color);
                        }
                        registrarAccion({ type: 'lightColor', objectId: obj.uuid, oldColor: oldColor, newColor: obj.color.getHex() });
                    }
                });
            }
        }


        function actualizarBotonesTransformacion() {
            document.querySelectorAll('.modo-transformacion button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(`btnModo${modoTransformacion.charAt(0).toUpperCase() + modoTransformacion.slice(1)}`).classList.add('active');
        }

        function establecerModoTransformacion(modo) {
            modoTransformacion = modo;
            actualizarBotonesTransformacion();
            if (objetoSeleccionado) {
                crearGizmos(objetoSeleccionado);
            }
            // Also update the left sidebar tool active state
            document.querySelectorAll('#sidebar-left .boton').forEach(btn => {
                btn.classList.remove('active');
            });
            if (modo === 'trasladar') document.getElementById('tool-move').classList.add('active');
            else if (modo === 'rotar') document.getElementById('tool-rotate').classList.add('active');
            else if (modo === 'escalar') document.getElementById('tool-scale').classList.add('active');
            
            mostrarToast(`Modo: ${modo.charAt(0).toUpperCase() + modo.slice(1)}`);
        }
        establecerModoTransformacion('trasladar'); // Default to move mode on startup

        function actualizarBotonesVisualizacion() {
            document.querySelectorAll('.modo-visualizacion button').forEach(btn => {
                btn.classList.remove('active');
            });
            const btnId = `btnModo${modoVisualizacion.charAt(0).toUpperCase() + modoVisualizacion.slice(1)}`;
            const btn = document.getElementById(btnId);
            if (btn) btn.classList.add('active');
        }

        function establecerModoVisualizacion(modo) {
            modoVisualizacion = modo;
            actualizarBotonesVisualizacion();
            aplicarModoVisualizacionAObjetos();
            mostrarToast(`Visualización: ${modo.charAt(0).toUpperCase() + modo.slice(1)}`);
        }
        establecerModoVisualizacion('normal'); // Modo normal por defecto

        function aplicarModoVisualizacionAObjetos() {
            objetos.forEach(obj => {
                if (obj.isMesh && obj.material) {
                    if (!obj.userData.originalMaterial) {
                        obj.userData.originalMaterial = obj.material.clone(); // Clone to preserve properties
                        obj.userData.originalMaterialColor = obj.material.color ? obj.material.color.getHex() : 0xffffff;
                        obj.userData.originalRoughness = obj.material.roughness;
                        obj.userData.originalMetalness = obj.material.metalness;
                        obj.userData.originalOpacity = obj.material.opacity;
                        obj.userData.originalTransparent = obj.material.transparent;
                    }

                    if (obj.userData.tipo === 'luzPunto') {
                        // Light helpers should always be visible and not change material
                        obj.material = obj.userData.originalMaterial;
                        return;
                    }

                    switch (modoVisualizacion) {
                        case 'normal':
                            obj.material = obj.userData.originalMaterial;
                            // Restore original material properties
                            if (obj.material.color) obj.material.color.set(obj.userData.originalMaterialColor);
                            if (obj.material.roughness !== undefined) obj.material.roughness = obj.userData.originalRoughness !== undefined ? obj.userData.originalRoughness : 0.5;
                            if (obj.material.metalness !== undefined) obj.material.metalness = obj.userData.originalMetalness !== undefined ? obj.userData.originalMetalness : 0;
                            if (obj.material.opacity !== undefined) obj.material.opacity = obj.userData.originalOpacity !== undefined ? obj.userData.originalOpacity : 1;
                            if (obj.material.transparent !== undefined) obj.material.transparent = obj.userData.originalTransparent !== undefined ? obj.userData.originalTransparent : false;

                            obj.material.wireframe = false;
                            if (obj.userData.bboxHelper) {
                                escena.remove(obj.userData.bboxHelper);
                                obj.userData.bboxHelper.dispose();
                                obj.userData.bboxHelper = null;
                            }
                            break;
                        case 'wireframe':
                            if (!obj.userData.wireframeMaterial) {
                                obj.userData.wireframeMaterial = new THREE.MeshBasicMaterial({
                                    color: obj.userData.originalMaterialColor || 0x00ff00,
                                    wireframe: true
                                });
                            }
                            obj.material = obj.userData.wireframeMaterial;
                            if (obj.userData.bboxHelper) {
                                escena.remove(obj.userData.bboxHelper);
                                obj.userData.bboxHelper.dispose();
                                obj.userData.bboxHelper = null;
                            }
                            break;
                        case 'bbox':
                            obj.material = obj.userData.originalMaterial;
                            obj.material.wireframe = false;
                            if (!obj.userData.bboxHelper) {
                                obj.userData.bboxHelper = new THREE.BoxHelper(obj, 0xffff00);
                                escena.add(obj.userData.bboxHelper);
                            }
                            break;
                    }
                    obj.material.needsUpdate = true;
                }
            });
            if (modoVisualizacion === 'bbox') {
                objetos.forEach(obj => {
                    if (obj.userData.bboxHelper) {
                        obj.userData.bboxHelper.update();
                    }
                });
            }
        }


        function toggleRiggingMode(activo) {
            riggingModeActivo = activo;
            mostrarToast(`Rigging Mode: ${riggingModeActivo ? 'Activado' : 'Desactivado'}`);

            if (riggingModeActivo) {
                eliminarGizmos();
                if (objetoSeleccionado && objetoSeleccionado.isSkinnedMesh) {
                    mostrarToast("Modo Rigging: Haz clic en los huesos para manipularlos.");
                    objetoSeleccionado.skeleton.bones.forEach(bone => {
                        const boneHelper = new THREE.AxesHelper(0.1);
                        bone.add(boneHelper);
                    });
                    escena.add(new THREE.SkeletonHelper(objetoSeleccionado.skeleton));
                }
            } else {
                if (objetoSeleccionado) {
                    crearGizmos(objetoSeleccionado);
                }
                escena.children.forEach(child => {
                    if (child instanceof THREE.SkeletonHelper) {
                        escena.remove(child);
                    }
                });
                if (objetoSeleccionado && objetoSeleccionado.isSkinnedMesh) {
                    objetoSeleccionado.skeleton.bones.forEach(bone => {
                        const helpers = bone.children.filter(c => c instanceof THREE.AxesHelper);
                        helpers.forEach(h => bone.remove(h));
                    });
                }
            }
        }

        function toggleAxesHelper(checked) {
            axesHelper.visible = checked;
            mostrarToast(`Ejes: ${checked ? 'Visible' : 'Oculto'}`);
            registrarAccion({ type: 'axesHelper', newState: checked, oldState: !checked });
        }

        function toggleGridHelper(checked) {
            gridHelper.visible = checked;
            mostrarToast(`Cuadrícula: ${checked ? 'Visible' : 'Oculto'}`);
            registrarAccion({ type: 'gridHelper', newState: checked, oldState: !checked });
        }


        // --- Funciones de Gestión de Escena y Objetos ---

        function agregarFigura(tipo) {
            let geo;
            let initialScale = new THREE.Vector3(1, 1, 1);
            let initialY = 0.6; // Default for most objects
            switch (tipo) {
                case 'cubo': geo = new THREE.BoxGeometry(1, 1, 1); break;
                case 'esfera': geo = new THREE.SphereGeometry(0.6, 32, 16); break;
                case 'cono': geo = new THREE.ConeGeometry(0.5, 1.2, 32); break;
                case 'cilindro': geo = new THREE.CylinderGeometry(0.5, 0.5, 1.2, 32); break;
                case 'toroide': geo = new THREE.TorusGeometry(0.5, 0.2, 16, 100); break;
                case 'plano': geo = new THREE.PlaneGeometry(5, 5); initialY = 0; break;
                case 'capsula': geo = new THREE.CapsuleGeometry(0.4, 1, 8, 16); break;
                default: return;
            }
            const mat = new THREE.MeshStandardMaterial({ color: Math.random() * 0xffffff });
            const figura = new THREE.Mesh(geo, mat);
            figura.position.set(Math.random() * 3 - 1.5, initialY, Math.random() * 3 - 1.5);
            
            contador[tipo]++;
            figura.name = tipo.charAt(0).toUpperCase() + tipo.slice(1) + " " + contador[tipo];
            figura.userData.tipo = tipo;
            figura.userData.initialPosition = figura.position.clone();
            figura.userData.initialRotation = figura.rotation.clone();
            figura.userData.initialScale = initialScale.clone();
            figura.userData.isLocked = false;

            // Store initial material properties for normal mode and undo/redo
            figura.userData.originalMaterial = figura.material.clone();
            figura.userData.originalMaterialColor = figura.material.color.getHex();
            figura.userData.originalRoughness = figura.material.roughness;
            figura.userData.originalMetalness = figura.material.metalness;
            figura.userData.originalOpacity = figura.material.opacity;
            figura.userData.originalTransparent = figura.material.transparent;

            escena.add(figura);
            objetos.push(figura);
            actualizarLista();
            seleccionarFigura(figura);
            mostrarToast(`✔️ ${figura.name} agregado.`);
            registrarAccion({ type: 'add', objectId: figura.uuid, objectData: serializarObjeto(figura) });
        }

        function agregarLuzPunto() {
            const pointLight = new THREE.PointLight(0xffffff, 1, 0);
            pointLight.position.set(Math.random() * 3 - 1.5, 2, Math.random() * 3 - 1.5);
            
            const sphereSize = 0.2;
            const pointLightHelper = new THREE.Mesh(
                new THREE.SphereGeometry(sphereSize, 16, 16),
                new THREE.MeshBasicMaterial({ color: pointLight.color, transparent: true, opacity: 0.5 })
            );
            pointLightHelper.name = "Helper " + (contador.luzPunto + 1);
            pointLight.add(pointLightHelper);

            contador.luzPunto++;
            pointLight.name = "Luz de Punto " + contador.luzPunto;
            pointLight.userData.tipo = 'luzPunto';
            pointLight.userData.initialPosition = pointLight.position.clone();
            pointLight.userData.initialRotation = pointLight.rotation.clone();
            pointLight.userData.initialScale = new THREE.Vector3(1,1,1);
            pointLight.userData.isLocked = false;

            escena.add(pointLight);
            objetos.push(pointLight);
            actualizarLista();
            seleccionarFigura(pointLight);
            mostrarToast(`✔️ ${pointLight.name} agregada.`);
            registrarAccion({ type: 'add', objectId: pointLight.uuid, objectData: serializarObjeto(pointLight) });
        }


        function duplicarFigura() {
            if (!objetoSeleccionado) {
                mostrarToast("☝️ Selecciona una figura para duplicar.");
                return;
            }
            if (objetoSeleccionado.userData.isLocked) {
                mostrarToast("🔒 Objeto bloqueado. Desbloquéalo para duplicar.");
                return;
            }

            const objData = serializarObjeto(objetoSeleccionado);
            delete objData.uuid;
            objData.keyframes = [];

            const nuevoObjeto = deserializarObjeto(objData);
            
            nuevoObjeto.position.x += 0.5;
            nuevoObjeto.position.y += 0.5;
            nuevoObjeto.position.z += 0.5;

            const tipo = nuevoObjeto.userData.tipo;
            contador[tipo]++;
            nuevoObjeto.name = tipo.charAt(0).toUpperCase() + tipo.slice(1) + " " + contador[tipo];
            nuevoObjeto.uuid = THREE.MathUtils.generateUUID();
            nuevoObjeto.userData.isLocked = false;

            escena.add(nuevoObjeto);
            objetos.push(nuevoObjeto);
            actualizarLista();
            seleccionarFigura(nuevoObjeto);
            mostrarToast(`✔️ ${nuevoObjeto.name} duplicado.`);
            registrarAccion({ type: 'add', objectId: nuevoObjeto.uuid, objectData: serializarObjeto(nuevoObjeto) });
        }

        function agruparObjetos() {
            if (objetosSeleccionadosMultiples.length < 2) {
                mostrarToast("☝️ Selecciona al menos dos objetos para agrupar (Ctrl/Cmd + clic).");
                return;
            }

            const grupo = new THREE.Group();
            contador.grupo++;
            grupo.name = "Grupo " + contador.grupo;
            grupo.userData.tipo = 'grupo';
            grupo.userData.isLocked = false;

            const bbox = new THREE.Box3();
            objetosSeleccionadosMultiples.forEach(obj => {
                bbox.expandByObject(obj);
            });
            const centro = new THREE.Vector3();
            bbox.getCenter(centro);
            grupo.position.copy(centro);

            objetosSeleccionadosMultiples.forEach(obj => {
                if (obj.userData.isLocked) {
                    mostrarToast(`🔒 No se puede agrupar el objeto bloqueado: ${obj.name}.`);
                    return;
                }
                grupo.attach(obj);
                const index = objetos.indexOf(obj);
                if (index > -1) {
                    objetos.splice(index, 1);
                }
            });

            grupo.userData.initialPosition = grupo.position.clone();
            grupo.userData.initialRotation = grupo.rotation.clone();
            grupo.userData.initialScale = grupo.scale.clone();

            escena.add(grupo);
            objetos.push(grupo);
            
            objetosSeleccionadosMultiples.length = 0;
            seleccionarFigura(grupo);
            actualizarLista();
            mostrarToast(`✔️ Grupo '${grupo.name}' creado con ${grupo.children.length} objetos.`);
            registrarAccion({ type: 'group', groupId: grupo.uuid, groupData: serializarObjeto(grupo), childUuids: grupo.children.map(c => c.uuid) });
        }

        function desagruparObjetos() {
            if (!objetoSeleccionado || objetoSeleccionado.userData.tipo !== 'grupo') {
                mostrarToast("☝️ Selecciona un grupo para desagrupar.");
                return;
            }
            if (objetoSeleccionado.userData.isLocked) {
                mostrarToast("🔒 Grupo bloqueado. Desbloquéalo para desagrupar.");
                return;
            }

            const grupo = objetoSeleccionado;
            const childUuids = grupo.children.map(c => c.uuid);
            const oldGroupData = serializarObjeto(grupo);

            for (let i = grupo.children.length - 1; i >= 0; i--) {
                const child = grupo.children[i];
                escena.attach(child);
                objetos.push(child);
            }

            escena.remove(grupo);
            const index = objetos.indexOf(grupo);
            if (index > -1) {
                objetos.splice(index, 1);
            }

            objetoSeleccionado = null;
            eliminarGizmos();
            updateObjectPropertiesPanel(null); // Clear object properties
            actualizarLista();
            mostrarToast(`✔️ Grupo '${grupo.name}' desagrupado.`);
            registrarAccion({ type: 'ungroup', oldGroupData: oldGroupData, childUuids: childUuids });
        }

        function resetearTransformacion() {
            if (!objetoSeleccionado) {
                mostrarToast("☝️ Selecciona una figura para resetear su transformación.");
                return;
            }
            if (objetoSeleccionado.userData.isLocked) {
                mostrarToast("🔒 Objeto bloqueado. Desbloquéalo para resetear.");
                return;
            }

            const oldState = {
                position: objetoSeleccionado.position.clone(),
                rotation: objetoSeleccionado.rotation.clone(),
                scale: objetoSeleccionado.scale.clone()
            };

            objetoSeleccionado.position.set(0, 0, 0);
            objetoSeleccionado.rotation.set(0, 0, 0);
            objetoSeleccionado.scale.set(1, 1, 1);

            if (objetoSeleccionado.userData.tipo === 'luzPunto') {
                objetoSeleccionado.position.copy(objetoSeleccionado.userData.initialPosition || new THREE.Vector3(0,2,0));
            } else if (objetoSeleccionado.userData.tipo === 'plano') {
                 objetoSeleccionado.position.copy(objetoSeleccionado.userData.initialPosition || new THREE.Vector3(0,0,0));
            }
            else {
                objetoSeleccionado.position.copy(objetoSeleccionado.userData.initialPosition || new THREE.Vector3(0,0.6,0));
            }
            objetoSeleccionado.rotation.copy(objetoSeleccionado.userData.initialRotation || new THREE.Euler(0,0,0));
            objetoSeleccionado.scale.copy(objetoSeleccionado.userData.initialScale || new THREE.Vector3(1,1,1));


            crearGizmos(objetoSeleccionado);
            updateTransformInputs(objetoSeleccionado); // Update UI inputs
            mostrarToast(`♻️ Transformación de ${objetoSeleccionado.name} reseteada.`);
            const newState = {
                position: objetoSeleccionado.position.clone(),
                rotation: objetoSeleccionado.rotation.clone(),
                scale: objetoSeleccionado.scale.clone()
            };
            registrarAccion({ type: 'transform', objectId: objetoSeleccionado.uuid, oldState: oldState, newState: newState });
        }


        function abrirImportadorModelo() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.glb, .gltf';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    cargarModeloGLB(file);
                }
            };
            input.click();
        }

        function cargarModeloGLB(file) {
            const reader = new FileReader();
            reader.onload = (event) => {
                const gltfLoader = new THREE.GLTFLoader();
                gltfLoader.parse(event.target.result, '', (gltf) => {
                    const model = gltf.scene;
                    model.position.set(Math.random() * 3 - 1.5, 0.6, Math.random() * 3 - 1.5);
                    model.scale.set(1, 1, 1);
                    contador.modelo++;
                    model.name = "Modelo " + contador.modelo;
                    model.userData.tipo = 'modelo';
                    model.userData.initialPosition = model.position.clone();
                    model.userData.initialRotation = model.rotation.clone();
                    model.userData.initialScale = model.scale.clone();
                    model.userData.gltfAnimations = gltf.animations;
                    model.userData.isLocked = false;

                    model.traverse((child) => {
                        if (child.isMesh && child.material) {
                            if (child.material.color) {
                                model.userData.lastColor = child.material.color.getHex();
                            }
                        }
                    });
                    if (model.userData.lastColor === undefined) {
                         model.userData.lastColor = new THREE.MeshStandardMaterial().color.getHex();
                    }

                    escena.add(model);
                    objetos.push(model);
                    actualizarLista();
                    seleccionarFigura(model);
                    mostrarToast(`✔️ Modelo '${model.name}' importado.`);
                    registrarAccion({ type: 'add', objectId: model.uuid, objectData: serializarObjeto(model) });
                }, (xhr) => {
                    if (xhr.lengthComputable) {
                        const percentComplete = xhr.loaded / xhr.total * 100;
                        mostrarToast(`Cargando modelo: ${percentComplete.toFixed(0)}%`, 1000);
                    }
                }, (error) => {
                    console.error('Error al cargar GLB/glTF:', error);
                    mostrarToast("❌ Error al cargar el modelo 3D.");
                });
            };
            reader.readAsArrayBuffer(file);
        }

        function abrirImportadorTextura() {
            if (!objetoSeleccionado || objetoSeleccionado.userData.tipo === 'luzPunto') {
                mostrarToast("☝️ Selecciona una figura (no una luz) para aplicarle una textura.");
                return;
            }
            if (objetoSeleccionado.userData.isLocked) {
                mostrarToast("🔒 Objeto bloqueado. Desbloquéalo para aplicar textura.");
                return;
            }

            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    aplicarTexturaAObjeto(objetoSeleccionado, file);
                }
            };
            input.click();
        }

        function aplicarTexturaAObjeto(obj, file) {
            const reader = new FileReader();
            reader.onload = (event) => {
                const textureLoader = new THREE.TextureLoader();
                textureLoader.load(event.target.result, (texture) => {
                    obj.userData.textureURL = event.target.result;

                    const oldMaterial = obj.material.clone();
                    let newMaterial;
                    if (obj.material instanceof THREE.MeshStandardMaterial) {
                        newMaterial = obj.material.clone();
                    } else {
                        newMaterial = new THREE.MeshStandardMaterial();
                        if (obj.material.color) newMaterial.color.copy(obj.material.color);
                    }
                    newMaterial.map = texture;
                    obj.material = newMaterial;
                    obj.material.needsUpdate = true;

                    mostrarToast(`✔️ Textura aplicada a ${obj.name}.`);
                    registrarAccion({ type: 'texture', objectId: obj.uuid, oldMaterialData: serializarMaterial(oldMaterial), newTextureURL: obj.userData.textureURL });
                }, undefined, (error) => {
                    console.error('Error al cargar la textura:', error);
                    mostrarToast("❌ Error al cargar la textura.");
                });
            };
            reader.readAsDataURL(file);
        }

        function serializarMaterial(material) {
            const data = {
                type: material.type,
                color: material.color ? material.color.getHex() : undefined,
                map: material.map ? material.map.image.src : undefined,
                roughness: material.roughness !== undefined ? material.roughness : undefined,
                metalness: material.metalness !== undefined ? material.metalness : undefined,
                opacity: material.opacity !== undefined ? material.opacity : undefined,
                transparent: material.transparent !== undefined ? material.transparent : undefined
            };
            return data;
        }

        function deserializarMaterial(materialData) {
            let material;
            if (materialData.type === 'MeshStandardMaterial') {
                material = new THREE.MeshStandardMaterial();
            } else if (materialData.type === 'MeshBasicMaterial') {
                material = new THREE.MeshBasicMaterial();
            } else {
                material = new THREE.MeshStandardMaterial();
            }

            if (materialData.color !== undefined) {
                material.color.set(materialData.color);
            }
            if (materialData.map) {
                const textureLoader = new THREE.TextureLoader();
                material.map = textureLoader.load(materialData.map);
            }
            if (materialData.roughness !== undefined) {
                material.roughness = materialData.roughness;
            }
            if (materialData.metalness !== undefined) {
                material.metalness = materialData.metalness;
            }
            if (materialData.opacity !== undefined) {
                material.opacity = materialData.opacity;
            }
            if (materialData.transparent !== undefined) {
                material.transparent = materialData.transparent;
            }
            return material;
        }


        function eliminarFigura(obj) {
            if (obj.userData.isLocked) {
                mostrarToast("🔒 Objeto bloqueado. Desbloquéalo para eliminar.");
                return;
            }
            mostrarDialogoConfirmacion('eliminar', obj);
        }

        function confirmarEliminar(obj) {
            const index = objetos.indexOf(obj);
            if (index > -1) {
                objetos.splice(index, 1);
                escena.remove(obj);
                if (objetoSeleccionado && objetoSeleccionado.uuid === obj.uuid) {
                    objetoSeleccionado = null;
                    eliminarGizmos();
                    updateObjectPropertiesPanel(null); // Clear object properties
                }
                if (obj.userData.bboxHelper) {
                    escena.remove(obj.userData.bboxHelper);
                    obj.userData.bboxHelper.dispose();
                    obj.userData.bboxHelper = null;
                }
                actualizarLista();
                mostrarToast(`🗑️ ${obj.name} eliminado.`);
                registrarAccion({ type: 'delete', objectData: serializarObjeto(obj) });
            }
        }

        function toggleBloquearObjeto(obj) {
            obj.userData.isLocked = !obj.userData.isLocked;
            actualizarLista();
            seleccionarFigura(obj); // Re-select to update UI state
            mostrarToast(`${obj.name} ${obj.userData.isLocked ? 'bloqueado 🔒' : 'desbloqueado 🔓'}.`);
            registrarAccion({ type: 'lock', objectId: obj.uuid, newState: obj.userData.isLocked });
        }


        function actualizarLista() {
            listaContenido.innerHTML = "";
            if (objetos.length === 0) {
                listaContenido.innerHTML = "<p style='padding: 10px; text-align: center; color: #aaa; font-size:var(--font-size-sm);'>No hay figuras en la escena.</p>";
                return;
            }
            objetos.forEach(obj => {
                const item = document.createElement("div");
                item.className = `itemLista ${objetoSeleccionado && objetoSeleccionado.uuid === obj.uuid ? 'seleccionado' : ''} ${obj.userData.isLocked ? 'bloqueado' : ''}`;
                obj.element = item;
                item.setAttribute('data-uuid', obj.uuid);

                const nameSpan = document.createElement("span");
                nameSpan.className = "nombre-item";
                nameSpan.textContent = obj.name;
                nameSpan.onclick = (e) => {
                    e.stopPropagation();
                    seleccionarFiguraDesdeLista(obj, e.ctrlKey || e.metaKey);
                };

                const renameInput = document.createElement("input");
                renameInput.type = "text";
                renameInput.value = obj.name;
                renameInput.style.display = "none";
                renameInput.addEventListener('click', (e) => e.stopPropagation());
                renameInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        const newName = renameInput.value.trim();
                        if (newName && newName !== obj.name) {
                            const oldName = obj.name;
                            obj.name = newName;
                            nameSpan.textContent = newName;
                            mostrarToast(`✔️ ${oldName} renombrado a ${newName}.`);
                            registrarAccion({ type: 'rename', objectId: obj.uuid, oldName: oldName, newName: newName });
                        }
                        renameInput.style.display = "none";
                        nameSpan.style.display = "block";
                    } else if (e.key === 'Escape') {
                        renameInput.value = obj.name;
                        renameInput.style.display = "none";
                        nameSpan.style.display = "block";
                    }
                });
                renameInput.addEventListener('blur', () => {
                    if (renameInput.style.display === "block") {
                        const newName = renameInput.value.trim();
                        if (newName && newName !== obj.name) {
                            const oldName = obj.name;
                            obj.name = newName;
                            nameSpan.textContent = newName;
                            mostrarToast(`✔️ ${oldName} renombrado a ${newName}.`);
                            registrarAccion({ type: 'rename', objectId: obj.uuid, oldName: oldName, newName: newName });
                        }
                        renameInput.style.display = "none";
                        nameSpan.style.display = "block";
                    }
                });

                const buttonsDiv = document.createElement("div");
                buttonsDiv.className = "botones-item";

                const lockButton = document.createElement("button");
                lockButton.className = `boton-bloquear-item ${obj.userData.isLocked ? 'active' : ''}`;
                lockButton.textContent = obj.userData.isLocked ? '🔓' : '🔒';
                lockButton.title = obj.userData.isLocked ? 'Desbloquear' : 'Bloquear';
                lockButton.onclick = (e) => {
                    e.stopPropagation();
                    toggleBloquearObjeto(obj);
                };

                const renameButton = document.createElement("button");
                renameButton.className = "boton-renombrar-item";
                renameButton.textContent = "✎";
                renameButton.title = "Renombrar";
                renameButton.onclick = (e) => {
                    e.stopPropagation();
                    if (obj.userData.isLocked) {
                        mostrarToast("🔒 Objeto bloqueado. Desbloquéalo para renombrar.");
                        return;
                    }
                    nameSpan.style.display = "none";
                    renameInput.style.display = "block";
                    renameInput.focus();
                    renameInput.select();
                };

                const deleteButton = document.createElement("button");
                deleteButton.className = "boton-eliminar-item";
                deleteButton.textContent = "X";
                deleteButton.title = "Eliminar";
                deleteButton.onclick = (e) => {
                    e.stopPropagation();
                    eliminarFigura(obj);
                };
                
                buttonsDiv.appendChild(lockButton);
                buttonsDiv.appendChild(renameButton);
                buttonsDiv.appendChild(deleteButton);
                
                item.appendChild(nameSpan);
                item.appendChild(renameInput);
                item.appendChild(buttonsDiv);
                listaContenido.appendChild(item);
            });
        }

        function seleccionarFiguraDesdeLista(obj, esMultiple = false) {
            if (obj.userData.isLocked && !esMultiple) {
                mostrarToast(`🔒 ${obj.name} está bloqueado.`);
                return;
            }

            if (esMultiple) {
                const index = objetosSeleccionadosMultiples.indexOf(obj);
                if (index > -1) {
                    objetosSeleccionadosMultiples.splice(index, 1);
                    obj.element.classList.remove('seleccionado');
                } else {
                    if (obj.userData.isLocked) {
                        mostrarToast(`🔒 ${obj.name} está bloqueado y no se puede seleccionar para agrupar.`);
                        return;
                    }
                    objetosSeleccionadosMultiples.push(obj);
                    obj.element.classList.add('seleccionado');
                }
                if (objetoSeleccionado && !objetosSeleccionadosMultiples.includes(objetoSeleccionado)) {
                    objetoSeleccionado = null;
                    eliminarGizmos();
                    updateObjectPropertiesPanel(null); // Clear object properties
                }
                mostrarToast(`Seleccionados: ${objetosSeleccionadosMultiples.length} objetos.`);
                actualizarLista();
            } else {
                objetosSeleccionadosMultiples.forEach(o => {
                    const listItem = document.querySelector(`.itemLista.seleccionado[data-uuid="${o.uuid}"]`);
                    if (listItem) listItem.classList.remove('seleccionado');
                });
                objetosSeleccionadosMultiples.length = 0;
                seleccionarFigura(obj);
            }
        }


        function seleccionarFigura(obj) {
            if (obj && obj.userData.isLocked) {
                mostrarToast(`🔒 ${obj.name} está bloqueado.`);
                return;
            }
            if (objetoSeleccionado === obj) return;
            if (objetoSeleccionado) {
                const oldItem = document.querySelector(`.itemLista.seleccionado`);
                if (oldItem) oldItem.classList.remove('seleccionado');
                if (objetoSeleccionado.isSkinnedMesh) {
                    escena.children.forEach(child => {
                        if (child instanceof THREE.SkeletonHelper) {
                            escena.remove(child);
                        }
                    });
                    objetoSeleccionado.skeleton.bones.forEach(bone => {
                        const helpers = bone.children.filter(c => c instanceof THREE.AxesHelper);
                        helpers.forEach(h => bone.remove(h));
                    });
                }
            }

            objetoSeleccionado = obj;
            if (!riggingModeActivo) {
                crearGizmos(objetoSeleccionado);
            } else {
                eliminarGizmos();
                if (objetoSeleccionado.isSkinnedMesh) {
                     escena.add(new THREE.SkeletonHelper(objetoSeleccionado.skeleton));
                     objetoSeleccionado.skeleton.bones.forEach(bone => {
                        const boneHelper = new THREE.AxesHelper(0.1);
                        bone.add(boneHelper);
                    });
                }
            }
            updateTransformInputs(objetoSeleccionado);
            updateObjectPropertiesPanel(objetoSeleccionado);
            
            mostrarToast(`✨ ${obj.name} seleccionado.`);
            actualizarLista();
        }

        function updateTransformInputs(obj) {
            if (obj) {
                posXInput.value = obj.position.x.toFixed(2);
                posYInput.value = obj.position.y.toFixed(2);
                posZInput.value = obj.position.z.toFixed(2);
                rotXInput.value = THREE.MathUtils.radToDeg(obj.rotation.x).toFixed(2);
                rotYInput.value = THREE.MathUtils.radToDeg(obj.rotation.y).toFixed(2);
                rotZInput.value = THREE.MathUtils.radToDeg(obj.rotation.z).toFixed(2);
                scaleXInput.value = obj.scale.x.toFixed(2);
                scaleYInput.value = obj.scale.y.toFixed(2);
                scaleZInput.value = obj.scale.z.toFixed(2);
            } else {
                posXInput.value = ''; posYInput.value = ''; posZInput.value = '';
                rotXInput.value = ''; rotYInput.value = ''; rotZInput.value = '';
                scaleXInput.value = ''; scaleYInput.value = ''; scaleZInput.value = '';
            }
        }


        function centrarFigura() {
            if (objetoSeleccionado) {
                if (objetoSeleccionado.userData.isLocked) {
                    mostrarToast("🔒 Objeto bloqueado. Desbloquéalo para centrar.");
                    return;
                }
                const oldPos = objetoSeleccionado.position.clone();
                objetoSeleccionado.position.set(0, objetoSeleccionado.position.y, 0);
                updateTransformInputs(objetoSeleccionado); // Update UI inputs
                mostrarToast(`🎯 ${objetoSeleccionado.name} centrado.`);
                registrarAccion({ type: 'transform', objectId: objetoSeleccionado.uuid, oldState: { position: oldPos.clone(), rotation: objetoSeleccionado.rotation.clone(), scale: objetoSeleccionado.scale.clone() }, newState: { position: objetoSeleccionado.position.clone(), rotation: objetoSeleccionado.rotation.clone(), scale: objetoSeleccionado.scale.clone() } });
            } else {
                mostrarToast("☝️ Selecciona una figura primero.");
            }
        }

        // --- Gizmos de Transformación ---
        const ESCALA_GIZMO = 0.5; /* Even more reduced gizmo scale */

        function crearGizmosTraslacion(obj) {
            const colores = [0xff0000, 0x00ff00, 0x0000ff];
            const ejes = ['x', 'y', 'z'];
            const rotaciones = [
                new THREE.Vector3(0, 0, -Math.PI / 2),
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(Math.PI / 2, 0, 0)
            ];

            for (let i = 0; i < 3; i++) {
                const grupo = new THREE.Group();
                const barra = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.015 * ESCALA_GIZMO, 0.015 * ESCALA_GIZMO, 0.8 * ESCALA_GIZMO, 8),
                    new THREE.MeshBasicMaterial({ color: colores[i], transparent: true, opacity: 0.8 }));
                barra.position.y = 0.4 * ESCALA_GIZMO;
                const punta = new THREE.Mesh(
                    new THREE.ConeGeometry(0.05 * ESCALA_GIZMO, 0.15 * ESCALA_GIZMO, 8),
                    new THREE.MeshBasicMaterial({ color: colores[i], transparent: true, opacity: 0.8 }));
                punta.position.y = 0.9 * ESCALA_GIZMO;
                grupo.add(barra);
                grupo.add(punta);

                grupo.rotation.set(rotaciones[i].x, rotaciones[i].y, rotaciones[i].z);
                grupo.position.copy(obj.position);
                grupo.userData.eje = ejes[i];
                grupo.userData.tipoGizmo = 'traslacion';
                escena.add(grupo);
                gizmos.push(grupo);
            }
        }

        function crearGizmosRotacion(obj) {
            const colores = [0xff0000, 0x00ff00, 0x0000ff];
            const ejes = ['x', 'y', 'z'];
            const rotaciones = [
                new THREE.Vector3(0, Math.PI / 2, 0),
                new THREE.Vector3(Math.PI / 2, 0, 0),
                new THREE.Vector3(0, 0, 0)
            ];
            const bbox = new THREE.Box3().setFromObject(obj);
            const size = new THREE.Vector3();
            bbox.getSize(size);
            const maxDim = Math.max(size.x, size.y, size.z);
            const radioAnillo = maxDim * 0.5 * ESCALA_GIZMO; /* Adjusted ring radius */

            for (let i = 0; i < 3; i++) {
                const anillo = new THREE.Mesh(
                    new THREE.TorusGeometry(radioAnillo, 0.01 * ESCALA_GIZMO, 16, 100), /* Adjusted tube radius */
                    new THREE.MeshBasicMaterial({ color: colores[i], transparent: true, opacity: 0.8, side: THREE.DoubleSide })
                );
                anillo.position.copy(obj.position);
                anillo.rotation.set(rotaciones[i].x, rotaciones[i].y, rotaciones[i].z);
                anillo.userData.eje = ejes[i];
                anillo.userData.tipoGizmo = 'rotacion';
                escena.add(anillo);
                gizmos.push(anillo);
            }
        }

        function crearGizmosEscala(obj) {
            gizmos = gizmos.filter(g => g.userData.tipoGizmo !== 'escala');

            const size = new THREE.Vector3();
            new THREE.Box3().setFromObject(obj).getSize(size);

            const halfSize = size.multiplyScalar(0.5);
            const posicionesRelativas = [
                new THREE.Vector3(halfSize.x, halfSize.y, halfSize.z),
                new THREE.Vector3(-halfSize.x, halfSize.y, halfSize.z),
                new THREE.Vector3(halfSize.x, -halfSize.y, halfSize.z),
                new THREE.Vector3(halfSize.x, halfSize.y, -halfSize.z),
                new THREE.Vector3(-halfSize.x, -halfSize.y, halfSize.z),
                new THREE.Vector3(-halfSize.x, halfSize.y, -halfSize.z),
                new THREE.Vector3(halfSize.x, -halfSize.y, -halfSize.z),
                new THREE.Vector3(-halfSize.x, -halfSize.y, -halfSize.z)
            ];

            const gizmoSize = 0.1 * ESCALA_GIZMO; /* Reduced gizmo size */
            for (const posRel of posicionesRelativas) {
                const cuboGizmo = new THREE.Mesh(
                    new THREE.BoxGeometry(gizmoSize, gizmoSize, gizmoSize),
                    new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.8 })
                );
                obj.add(cuboGizmo);
                cuboGizmo.position.copy(posRel);

                cuboGizmo.userData.tipoGizmo = 'escala';
                cuboGizmo.userData.direccionLocalEscala = posRel.clone().normalize();
                gizmos.push(cuboGizmo);
            }
        }


        function crearGizmos(obj) {
            eliminarGizmos();
            if (!obj) return;
            if (riggingModeActivo) return;
            if (obj.userData.isLocked) return;

            switch (modoTransformacion) {
                case 'trasladar':
                    crearGizmosTraslacion(obj);
                    break;
                case 'rotar':
                    crearGizmosRotacion(obj);
                    break;
                case 'escalar':
                    crearGizmosEscala(obj);
                    break;
            }
        }

        function eliminarGizmos() {
            gizmos.forEach(g => {
                if (g.parent) {
                    g.parent.remove(g);
                } else {
                    escena.remove(g);
                }
            });
            gizmos = [];
        }

        // --- Manejo de Eventos Táctiles ---
        let tocando = false;
        let objetoArrastrando = null;
        let ultimoEstadoObjeto = null;

        render.domElement.addEventListener("touchstart", e => {
            if (riggingModeActivo) {
                controls.enabled = false;
                return;
            }
            controls.enabled = true;

            if (e.touches.length === 1) {
                previousTouchPos.set(e.touches[0].clientX, e.touches[0].clientY);
                tocando = true;
                objetoArrastrando = null;

                const rect = render.domElement.getBoundingClientRect();
                puntero.x = ((e.touches[0].clientX - rect.left) / rect.width) * 2 - 1;
                puntero.y = -((e.touches[0].clientY - rect.top) / rect.height) * 2 + 1;
                raycaster.setFromCamera(puntero, camara);

                const interGizmo = raycaster.intersectObjects(gizmos, true);

                if (interGizmo.length > 0 && objetoSeleccionado) {
                    let hitGizmo = interGizmo[0].object;
                    while (hitGizmo && !hitGizmo.userData.tipoGizmo) {
                        hitGizmo = hitGizmo.parent;
                    }

                    if (hitGizmo && (hitGizmo.userData.tipoGizmo === 'traslacion' || hitGizmo.userData.tipoGizmo === 'rotacion' || hitGizmo.userData.tipoGizmo === 'escala')) {
                        if (objetoSeleccionado.userData.isLocked) {
                            mostrarToast("🔒 Objeto bloqueado. Desbloquéalo para mover.");
                            return;
                        }
                        objetoArrastrando = hitGizmo;

                        if (objetoArrastrando.userData.tipoGizmo === 'traslacion') {
                            puntoInterseccionInicial3D.copy(interGizmo[0].point);
                        }

                        ultimoEstadoObjeto = {
                            position: objetoSeleccionado.position.clone(),
                            rotation: objetoSeleccionado.rotation.clone(),
                            scale: objetoSeleccionado.scale.clone()
                        };
                        controls.enabled = false;
                        e.preventDefault();
                        return;
                    }
                }

                const interObj = raycaster.intersectObjects(objetos);
                if (interObj.length > 0) {
                    seleccionarFigura(interObj[0].object);
                    controls.enabled = false;
                    e.preventDefault();
                    return;
                }

                if (objetoSeleccionado) {
                    objetoSeleccionado = null;
                    eliminarGizmos();
                    updateObjectPropertiesPanel(null); // Clear object properties
                    actualizarLista();
                    mostrarToast("🤷‍♂️ Nada seleccionado.");
                }

            } else if (e.touches.length === 2) {
                controls.enabled = true;
                objetoArrastrando = null;
            }
        }, { passive: false });

        render.domElement.addEventListener("touchmove", e => {
            if (riggingModeActivo) {
                return;
            }
            if (controls.enabled) {
                return;
            }
            if (!tocando || !objetoSeleccionado || e.touches.length > 1) {
                return;
            }
            if (objetoSeleccionado.userData.isLocked) {
                return;
            }

            e.preventDefault();

            const rect = render.domElement.getBoundingClientRect();
            const currentTouchX = e.touches[0].clientX;
            const currentTouchY = e.touches[0].clientY;

            let deltaPixelX = 0;
            let deltaPixelY = 0;
            if (objetoArrastrando.userData.tipoGizmo === 'rotacion' || objetoArrastrando.userData.tipoGizmo === 'escala') {
                deltaPixelX = currentTouchX - previousTouchPos.x;
                deltaPixelY = currentTouchY - previousTouchPos.y;
            }

            const sensitivity = velocidadMovimiento;

            if (objetoArrastrando.userData.tipoGizmo === 'traslacion') {
                const eje = objetoArrastrando.userData.eje;
                
                puntero.x = ((currentTouchX - rect.left) / rect.width) * 2 - 1;
                puntero.y = -((e.touches[0].clientY - rect.top) / rect.height) * 2 + 1;
                raycaster.setFromCamera(puntero, camara);

                const cameraDirection = new THREE.Vector3();
                camara.getWorldDirection(cameraDirection);
                const plane = new THREE.Plane();
                plane.setFromNormalAndCoplanarPoint(cameraDirection, puntoInterseccionInicial3D);

                const nuevaInterseccion3D = new THREE.Vector3();
                if (!raycaster.ray.intersectPlane(plane, nuevaInterseccion3D)) {
                    return;
                }

                const deltaMovimiento3D = new THREE.Vector3().subVectors(nuevaInterseccion3D, puntoInterseccionInicial3D);

                const axisWorld = new THREE.Vector3();
                if (eje === 'x') axisWorld.set(1, 0, 0);
                else if (eje === 'y') axisWorld.set(0, 1, 0);
                else if (eje === 'z') axisWorld.set(0, 0, 1);
                axisWorld.normalize();

                const moveAmount = deltaMovimiento3D.dot(axisWorld);
                objetoSeleccionado.position.add(axisWorld.multiplyScalar(moveAmount));
                puntoInterseccionInicial3D.copy(nuevaInterseccion3D);

                gizmos.forEach(g => {
                    if (g.userData.tipoGizmo === 'traslacion') {
                        g.position.copy(objetoSeleccionado.position);
                    }
                });
                updateTransformInputs(objetoSeleccionado); // Update UI inputs

            } else if (objetoArrastrando.userData.tipoGizmo === 'rotacion') {
                const eje = objetoArrastrando.userData.eje;
                const rotationSpeed = sensitivity * 0.005;

                let deltaRotation = 0;
                let axis = new THREE.Vector3();

                if (eje === 'x') {
                    axis.set(1, 0, 0);
                    deltaRotation = -deltaPixelY * rotationSpeed;
                } else if (eje === 'y') {
                    axis.set(0, 1, 0);
                    deltaRotation = deltaPixelX * rotationSpeed;
                } else if (eje === 'z') {
                    axis.set(0, 0, 1);
                    deltaRotation = (deltaPixelX - deltaPixelY) * rotationSpeed;
                }
                objetoSeleccionado.rotateOnWorldAxis(axis, deltaRotation);
                gizmos.filter(g => g.userData.tipoGizmo === 'rotacion').forEach(g => g.position.copy(objetoSeleccionado.position));
                updateTransformInputs(objetoSeleccionado); // Update UI inputs

            } else if (objetoArrastrando.userData.tipoGizmo === 'escala') {
                const scaleSpeed = sensitivity * 0.01;
                const deltaScale = (deltaPixelX - deltaPixelY) * scaleSpeed;

                const currentScale = objetoSeleccionado.scale.x;
                let newScale = currentScale + deltaScale;
                newScale = Math.max(0.01, newScale);

                objetoSeleccionado.scale.set(newScale, newScale, newScale);
                updateTransformInputs(objetoSeleccionado); // Update UI inputs
            }
            previousTouchPos.set(currentTouchX, currentTouchY);

        }, { passive: false });

        render.domElement.addEventListener("touchend", () => {
            tocando = false;
            if (riggingModeActivo) {
                return;
            }

            if (objetoArrastrando && objetoSeleccionado) {
                const newState = {
                    position: objetoSeleccionado.position.clone(),
                    rotation: objetoSeleccionado.rotation.clone(),
                    scale: objetoSeleccionado.scale.clone()
                };
                if (ultimoEstadoObjeto && (
                    !ultimoEstadoObjeto.position.equals(newState.position) ||
                    !ultimoEstadoObjeto.rotation.equals(newState.rotation) ||
                    !ultimoEstadoObjeto.scale.equals(newState.scale)
                )) {
                    registrarAccion({ type: 'transform', objectId: objetoSeleccionado.uuid, oldState: ultimoEstadoObjeto, newState: newState });
                }
                ultimoEstadoObjeto = null;
                objetoArrastrando = null;
            }
            controls.enabled = true;
        });

        // --- Historial de Acciones (Undo/Redo) ---

        const historial = [];
        let indiceHistorial = -1;
        const MAX_HISTORIAL = 50;

        function registrarAccion(accion) {
            if (indiceHistorial < historial.length - 1) {
                historial.splice(indiceHistorial + 1);
            }
            historial.push(accion);
            if (historial.length > MAX_HISTORIAL) {
                historial.shift();
            }
            indiceHistorial = historial.length - 1;
            actualizarBotonesUndoRedo();
        }

        function deshacerAccion() {
            if (indiceHistorial < 0) {
                mostrarToast("🤷‍♀️ No hay acciones para deshacer.");
                return;
            }

            const accion = historial[indiceHistorial];
            const obj = escena.getObjectByProperty('uuid', accion.objectId);

            switch (accion.type) {
                case 'add':
                    if (obj) {
                        escena.remove(obj);
                        objetos.splice(objetos.indexOf(obj), 1);
                        if (objetoSeleccionado === obj) {
                            objetoSeleccionado = null;
                            eliminarGizmos();
                            updateObjectPropertiesPanel(null);
                        }
                        if (obj.userData.bboxHelper) {
                            escena.remove(obj.userData.bboxHelper);
                            obj.userData.bboxHelper.dispose();
                            obj.userData.bboxHelper = null;
                        }
                        actualizarLista();
                        mostrarToast(`↩ Deshecho: Añadir ${obj.name}`);
                    }
                    break;
                case 'delete':
                    if (accion.objectData) {
                        const newObj = deserializarObjeto(accion.objectData);
                        escena.add(newObj);
                        objetos.push(newObj);
                        actualizarLista();
                        seleccionarFigura(newObj);
                        mostrarToast(`↩ Deshecho: Eliminar ${newObj.name}`);
                    }
                    break;
                case 'transform':
                    if (obj && accion.oldState) {
                        obj.position.copy(accion.oldState.position);
                        obj.rotation.copy(accion.oldState.rotation);
                        obj.scale.copy(accion.oldState.scale);
                        if (objetoSeleccionado === obj) {
                            crearGizmos(obj);
                            updateTransformInputs(obj);
                        }
                        mostrarToast(`↩ Deshecho: Mover ${obj.name}`);
                    }
                    break;
                case 'color':
                    if (obj && accion.oldColor !== undefined) {
                        if (obj.isMesh && obj.material) {
                            obj.material.color.set(accion.oldColor);
                        } else if (obj.userData.tipo === 'modelo') {
                            obj.traverse((child) => {
                                if (child.isMesh && child.material) {
                                    child.material.color.set(accion.oldColor);
                                }
                            });
                            obj.userData.lastColor = accion.oldColor;
                        }
                        if (objetoSeleccionado === obj) {
                            updateObjectPropertiesPanel(obj);
                        }
                        mostrarToast(`↩ Deshecho: Color ${obj.name}`);
                    }
                    break;
                case 'texture':
                    if (obj && accion.oldMaterialData) {
                        obj.material = deserializarMaterial(accion.oldMaterialData);
                        obj.material.needsUpdate = true;
                        obj.userData.textureURL = accion.oldMaterialData.map;
                        if (objetoSeleccionado === obj) {
                            updateObjectPropertiesPanel(obj);
                        }
                        mostrarToast(`↩ Deshecho: Textura para ${obj.name}`);
                    }
                    break;
                case 'rename':
                    if (obj && accion.oldName !== undefined) {
                        obj.name = accion.oldName;
                        actualizarLista();
                        mostrarToast(`↩ Deshecho: Renombrar a ${obj.name}`);
                    }
                    break;
                case 'ambientIntensity':
                    if (accion.oldIntensity !== undefined) {
                        ambientLight.intensity = accion.oldIntensity;
                        ambientLightIntensitySlider.value = accion.oldIntensity;
                        ambientLightIntensityLabel.textContent = accion.oldIntensity.toFixed(2);
                        mostrarToast(`↩ Deshecho: Intensidad Luz Ambiente`);
                    }
                    break;
                case 'ambientColor':
                    if (accion.oldColor !== undefined) {
                        ambientLight.color.set(accion.oldColor);
                        ambientLightColorPicker.value = "#" + new THREE.Color(accion.oldColor).getHexString();
                        mostrarToast(`↩ Deshecho: Color Luz Ambiente`);
                    }
                    break;
                case 'directionalIntensity':
                    if (accion.oldIntensity !== undefined) {
                        directionalLight.intensity = accion.oldIntensity;
                        directionalLightIntensitySlider.value = accion.oldIntensity;
                        directionalLightIntensityLabel.textContent = directionalLight.intensity.toFixed(2);
                        mostrarToast(`↩ Deshecho: Intensidad Luz Direccional`);
                    }
                    break;
                case 'directionalColor':
                    if (accion.oldColor !== undefined) {
                        directionalLight.color.set(accion.oldColor);
                        directionalLightColorPicker.value = "#" + new THREE.Color(accion.oldColor).getHexString();
                        mostrarToast(`↩ Deshecho: Color Luz Direccional`);
                    }
                    break;
                case 'skybox':
                    toggleSkybox(!accion.newState);
                    skyboxCheckbox.checked = !accion.newState;
                    mostrarToast(`↩ Deshecho: Skybox ${!accion.newState ? 'Activado' : 'Desactivado'}`);
                    break;
                case 'lock':
                    if (obj) {
                        obj.userData.isLocked = !accion.newState;
                        actualizarLista();
                        if (objetoSeleccionado === obj) {
                            crearGizmos(obj);
                        } else if (obj.userData.isLocked) {
                             eliminarGizmos();
                        }
                        mostrarToast(`↩ Deshecho: ${obj.name} ${obj.userData.isLocked ? 'bloqueado' : 'desbloqueado'}`);
                    }
                    break;
                case 'group':
                    if (obj) {
                        escena.remove(obj);
                        objetos.splice(objetos.indexOf(obj), 1);

                        accion.childUuids.forEach(childUuid => {
                            const childObj = escena.getObjectByProperty('uuid', childUuid);
                            if (childObj) {
                                escena.attach(childObj);
                                objetos.push(childObj);
                            }
                        });
                        objetoSeleccionado = null;
                        eliminarGizmos();
                        updateObjectPropertiesPanel(null);
                        actualizarLista();
                        mostrarToast(`↩ Deshecho: Agrupar ${obj.name}`);
                    }
                    break;
                case 'ungroup':
                    if (obj) {
                        const oldGroup = deserializarObjeto(accion.oldGroupData);
                        escena.add(oldGroup);
                        objetos.push(oldGroup);
                        
                        accion.childUuids.forEach(childUuid => {
                            const childObj = escena.getObjectByProperty('uuid', childUuid);
                            if (childObj) {
                                oldGroup.attach(childObj);
                                const idx = objetos.indexOf(childObj);
                                if (idx > -1) objetos.splice(idx, 1);
                            }
                        });
                        seleccionarFigura(oldGroup);
                        actualizarLista();
                        mostrarToast(`↩ Deshecho: Desagrupar ${oldGroup.name}`);
                    }
                    break;
                case 'lightIntensity':
                    if (obj && obj.userData.tipo === 'luzPunto' && accion.oldIntensity !== undefined) {
                        obj.intensity = accion.oldIntensity;
                        if (objetoSeleccionado === obj) {
                            updateObjectPropertiesPanel(obj);
                        }
                        mostrarToast(`↩ Deshecho: Intensidad de luz ${obj.name}`);
                    }
                    break;
                case 'lightDistance':
                    if (obj && obj.userData.tipo === 'luzPunto' && accion.oldDistance !== undefined) {
                        obj.distance = accion.oldDistance;
                        if (objetoSeleccionado === obj) {
                            updateObjectPropertiesPanel(obj);
                        }
                        mostrarToast(`↩ Deshecho: Distancia de luz ${obj.name}`);
                    }
                    break;
                case 'lightColor':
                    if (obj && obj.userData.tipo === 'luzPunto' && accion.oldColor !== undefined) {
                        obj.color.set(accion.oldColor);
                        if (objetoSeleccionado === obj) {
                            updateObjectPropertiesPanel(obj);
                            const helper = obj.children.find(c => c.name.startsWith(`Helper `));
                            if (helper && helper.material) {
                                helper.material.color.set(obj.color);
                            }
                        }
                        mostrarToast(`↩ Deshecho: Color de luz ${obj.name}`);
                    }
                    break;
                case 'materialProp':
                    if (obj && obj.isMesh && obj.material && accion.prop && accion.oldValue !== undefined) {
                        if (accion.prop === 'transparent') {
                            obj.material.transparent = accion.oldValue;
                            if (!accion.oldValue && obj.material.opacity < 1) { // If reverting to non-transparent, reset opacity
                                obj.material.opacity = 1;
                            }
                        } else {
                            obj.material[accion.prop] = accion.oldValue;
                        }
                        obj.material.needsUpdate = true;
                        if (objetoSeleccionado === obj) {
                            updateObjectPropertiesPanel(obj);
                        }
                        mostrarToast(`↩ Deshecho: Propiedad de material (${accion.prop}) de ${obj.name}`);
                    }
                    break;
                case 'axesHelper':
                    axesHelper.visible = accion.oldState;
                    axesHelperCheckbox.checked = accion.oldState;
                    mostrarToast(`↩ Deshecho: Ejes ${accion.oldState ? 'Visible' : 'Oculto'}`);
                    break;
                case 'gridHelper':
                    gridHelper.visible = accion.oldState;
                    gridHelperCheckbox.checked = accion.oldState;
                    mostrarToast(`↩ Deshecho: Cuadrícula ${accion.oldState ? 'Visible' : 'Oculto'}`);
                    break;
            }
            indiceHistorial--;
            actualizarBotonesUndoRedo();
        }

        function rehacerAccion() {
            if (indiceHistorial >= historial.length - 1) {
                mostrarToast("🤷‍♀️ No hay acciones para rehacer.");
                return;
            }
            indiceHistorial++;
            const accion = historial[indiceHistorial];
            const obj = escena.getObjectByProperty('uuid', accion.objectId);

            switch (accion.type) {
                case 'add':
                    if (accion.objectData) {
                        const newObj = deserializarObjeto(accion.objectData);
                        escena.add(newObj);
                        objetos.push(newObj);
                        actualizarLista();
                        seleccionarFigura(newObj);
                        mostrarToast(`↪ Rehaciendo: Añadir ${newObj.name}`);
                    }
                    break;
                case 'delete':
                    if (obj) {
                        escena.remove(obj);
                        objetos.splice(objetos.indexOf(obj), 1);
                        if (objetoSeleccionado === obj) {
                            objetoSeleccionado = null;
                            eliminarGizmos();
                            updateObjectPropertiesPanel(null);
                        }
                        if (obj.userData.bboxHelper) {
                            escena.remove(obj.userData.bboxHelper);
                            obj.userData.bboxHelper.dispose();
                            obj.userData.bboxHelper = null;
                        }
                        actualizarLista();
                        mostrarToast(`↪ Rehaciendo: Eliminar ${obj.name}`);
                    }
                    break;
                case 'transform':
                    if (obj && accion.newState) {
                        obj.position.copy(accion.newState.position);
                        obj.rotation.copy(accion.newState.rotation);
                        obj.scale.copy(accion.newState.scale);
                        if (objetoSeleccionado === obj) {
                            crearGizmos(obj);
                            updateTransformInputs(obj);
                        }
                        mostrarToast(`↪ Rehaciendo: Mover ${obj.name}`);
                    }
                    break;
                case 'color':
                    if (obj && accion.newColor !== undefined) {
                        if (obj.isMesh && obj.material) {
                            obj.material.color.set(accion.newColor);
                        } else if (obj.userData.tipo === 'modelo') {
                            obj.traverse((child) => {
                                if (child.isMesh && child.material) {
                                    child.material.color.set(accion.newColor);
                                }
                            });
                            obj.userData.lastColor = accion.newColor;
                        }
                        if (objetoSeleccionado === obj) {
                            updateObjectPropertiesPanel(obj);
                        }
                        mostrarToast(`↪ Rehaciendo: Color ${obj.name}`);
                    }
                    break;
                case 'texture':
                    if (obj && accion.newTextureURL) {
                        const textureLoader = new THREE.TextureLoader();
                        textureLoader.load(accion.newTextureURL, (texture) => {
                            let newMaterial;
                            if (obj.material instanceof THREE.MeshStandardMaterial) {
                                newMaterial = obj.material.clone();
                            } else {
                                newMaterial = new THREE.MeshStandardMaterial();
                                if (obj.material.color) newMaterial.color.copy(obj.material.color);
                            }
                            newMaterial.map = texture;
                            obj.material = newMaterial;
                            obj.material.needsUpdate = true;
                            obj.userData.textureURL = accion.newTextureURL;
                            if (objetoSeleccionado === obj) {
                                updateObjectPropertiesPanel(obj);
                            }
                            mostrarToast(`↪ Rehaciendo: Textura para ${obj.name}`);
                        });
                    }
                    break;
                case 'rename':
                    if (obj && accion.newName !== undefined) {
                        obj.name = accion.newName;
                        actualizarLista();
                        mostrarToast(`↪ Rehaciendo: Renombrar a ${obj.name}`);
                    }
                    break;
                case 'ambientIntensity':
                    if (accion.newIntensity !== undefined) {
                        ambientLight.intensity = accion.newIntensity;
                        ambientLightIntensitySlider.value = accion.newIntensity;
                        ambientLightIntensityLabel.textContent = accion.newIntensity.toFixed(2);
                        mostrarToast(`↪ Rehaciendo: Intensidad Luz Ambiente`);
                    }
                    break;
                case 'ambientColor':
                    if (accion.newColor !== undefined) {
                        ambientLight.color.set(accion.newColor);
                        ambientLightColorPicker.value = "#" + new THREE.Color(accion.newColor).getHexString();
                        mostrarToast(`↪ Rehaciendo: Color Luz Ambiente`);
                    }
                    break;
                case 'directionalIntensity':
                    if (accion.newIntensity !== undefined) {
                        directionalLight.intensity = accion.newIntensity;
                        directionalLightIntensitySlider.value = accion.newIntensity;
                        directionalLightIntensityLabel.textContent = directionalLight.intensity.toFixed(2);
                        mostrarToast(`↪ Rehaciendo: Intensidad Luz Direccional`);
                    }
                    break;
                case 'directionalColor':
                    if (accion.newColor !== undefined) {
                        directionalLight.color.set(accion.newColor);
                        directionalLightColorPicker.value = "#" + new THREE.Color(accion.newColor).getHexString();
                        mostrarToast(`↪ Rehaciendo: Color Luz Direccional`);
                    }
                    break;
                case 'skybox':
                    toggleSkybox(accion.newState);
                    skyboxCheckbox.checked = accion.newState;
                    mostrarToast(`↪ Rehaciendo: Skybox ${accion.newState ? 'Activado' : 'Desactivado'}`);
                    break;
                case 'lock':
                    if (obj) {
                        obj.userData.isLocked = accion.newState;
                        actualizarLista();
                        if (objetoSeleccionado === obj) {
                            if (obj.userData.isLocked) {
                                eliminarGizmos();
                            } else {
                                crearGizmos(obj);
                            }
                        }
                        mostrarToast(`↪ Rehaciendo: ${obj.name} ${obj.userData.isLocked ? 'bloqueado' : 'desbloqueado'}`);
                    }
                    break;
                case 'group':
                    if (accion.groupData) {
                        const newGroup = deserializarObjeto(accion.groupData);
                        escena.add(newGroup);
                        objetos.push(newGroup);

                        accion.childUuids.forEach(childUuid => {
                            const childObj = escena.getObjectByProperty('uuid', childUuid);
                            if (childObj) {
                                newGroup.attach(childObj);
                                const idx = objetos.indexOf(childObj);
                                if (idx > -1) objetos.splice(idx, 1);
                            }
                        });
                        seleccionarFigura(newGroup);
                        actualizarLista();
                        mostrarToast(`↪ Rehaciendo: Agrupar ${newGroup.name}`);
                    }
                    break;
                case 'ungroup':
                    if (obj) {
                        const oldGroup = deserializarObjeto(accion.oldGroupData);
                        escena.remove(oldGroup);
                        accion.childUuids.forEach(childUuid => {
                            const childObj = escena.getObjectByProperty('uuid', childUuid);
                            if (childObj) {
                                oldGroup.remove(childObj);
                                escena.add(childObj);
                                objetos.push(childObj);
                            }
                        });
                        objetoSeleccionado = null;
                        eliminarGizmos();
                        updateObjectPropertiesPanel(null);
                        actualizarLista();
                        mostrarToast(`↪ Rehaciendo: Desagrupar ${oldGroup.name}`);
                    }
                    break;
                case 'lightIntensity':
                    if (obj && obj.userData.tipo === 'luzPunto' && accion.newIntensity !== undefined) {
                        obj.intensity = accion.newIntensity;
                        if (objetoSeleccionado === obj) {
                            updateObjectPropertiesPanel(obj);
                        }
                        mostrarToast(`↪ Rehaciendo: Intensidad de luz ${obj.name}`);
                    }
                    break;
                case 'lightDistance':
                    if (obj && obj.userData.tipo === 'luzPunto' && accion.newDistance !== undefined) {
                        obj.distance = accion.newDistance;
                        if (objetoSeleccionado === obj) {
                            updateObjectPropertiesPanel(obj);
                        }
                        mostrarToast(`↪ Rehaciendo: Distancia de luz ${obj.name}`);
                    }
                    break;
                case 'lightColor':
                    if (obj && obj.userData.tipo === 'luzPunto' && accion.newColor !== undefined) {
                        obj.color.set(accion.newColor);
                        if (objetoSeleccionado === obj) {
                            updateObjectPropertiesPanel(obj);
                             const helper = obj.children.find(c => c.name.startsWith(`Helper `));
                            if (helper && helper.material) {
                                helper.material.color.set(obj.color);
                            }
                        }
                        mostrarToast(`↪ Rehaciendo: Color de luz ${obj.name}`);
                    }
                    break;
                case 'materialProp':
                    if (obj && obj.isMesh && obj.material && accion.prop && accion.newValue !== undefined) {
                        if (accion.prop === 'transparent') {
                            obj.material.transparent = accion.newValue;
                            if (!accion.newValue && obj.material.opacity < 1) { // If redoing to non-transparent, reset opacity
                                obj.material.opacity = 1;
                            }
                        } else {
                            obj.material[accion.prop] = accion.newValue;
                        }
                        obj.material.needsUpdate = true;
                        if (objetoSeleccionado === obj) {
                            updateObjectPropertiesPanel(obj);
                        }
                        mostrarToast(`↪ Rehaciendo: Propiedad de material (${accion.prop}) de ${obj.name}`);
                    }
                    break;
                case 'axesHelper':
                    axesHelper.visible = accion.newState;
                    axesHelperCheckbox.checked = accion.newState;
                    mostrarToast(`↪ Rehaciendo: Ejes ${accion.newState ? 'Visible' : 'Oculto'}`);
                    break;
                case 'gridHelper':
                    gridHelper.visible = accion.newState;
                    gridHelperCheckbox.checked = accion.newState;
                    mostrarToast(`↪ Rehaciendo: Cuadrícula ${accion.newState ? 'Visible' : 'Oculto'}`);
                    break;
            }
            actualizarBotonesUndoRedo();
        }

        function actualizarBotonesUndoRedo() {
            document.getElementById('btnDeshacer').disabled = indiceHistorial < 0;
            document.getElementById('btnRehacer').disabled = indiceHistorial >= historial.length - 1;
        }
        actualizarBotonesUndoRedo();

        // --- Guardar/Cargar Escena ---

        function serializarObjeto(obj) {
            const data = {
                uuid: obj.uuid,
                name: obj.name,
                type: obj.userData.tipo,
                position: obj.position.toArray(),
                rotation: obj.rotation.toArray(),
                scale: obj.scale.toArray(),
                isLocked: obj.userData.isLocked || false,
                keyframes: keyframes.has(obj.uuid) ? keyframes.get(obj.uuid).map(v => ({ position: v.position.toArray(), rotation: v.rotation.toArray(), scale: v.scale.toArray() })) : []
            };

            if (obj.userData.tipo === 'luzPunto') {
                data.lightColor = obj.color.getHex();
                data.lightIntensity = obj.intensity;
                data.lightDistance = obj.distance;
            } else if (obj.material) {
                data.materialData = serializarMaterial(obj.material);
                data.textureURL = obj.userData.textureURL || null;
            }

            if (obj.userData.gltfAnimations) {
                data.gltfAnimations = obj.userData.gltfAnimations.map(anim => anim.name);
            }
            
            if (obj.userData.tipo === 'grupo' && obj.children.length > 0) {
                data.childrenUuids = obj.children.map(child => child.uuid);
            }

            return data;
        }

        function deserializarObjeto(data) {
            let obj;
            if (data.type === 'modelo') {
                obj = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), new THREE.MeshStandardMaterial({ color: 0x888888 }));
                obj.name = data.name + " (Placeholder)";
            } else if (data.type === 'luzPunto') {
                obj = new THREE.PointLight(data.lightColor, data.lightIntensity, data.lightDistance);
                const sphereSize = 0.2;
                const pointLightHelper = new THREE.Mesh(
                    new THREE.SphereGeometry(sphereSize, 16, 16),
                    new THREE.MeshBasicMaterial({ color: obj.color, transparent: true, opacity: 0.5 })
                );
                pointLightHelper.name = "Helper " + data.name.split(' ')[2];
                obj.add(pointLightHelper);
            } else if (data.type === 'grupo') {
                obj = new THREE.Group();
            }
            else {
                let geo;
                switch (data.type) {
                    case 'cubo': geo = new THREE.BoxGeometry(1, 1, 1); break;
                    case 'esfera': geo = new THREE.SphereGeometry(0.6, 32, 16); break;
                    case 'cono': geo = new THREE.ConeGeometry(0.5, 1.2, 32); break;
                    case 'cilindro': geo = new THREE.CylinderGeometry(0.5, 0.5, 1.2, 32); break;
                    case 'toroide': geo = new THREE.TorusGeometry(0.5, 0.2, 16, 100); break;
                    case 'plano': geo = new THREE.PlaneGeometry(5, 5); break;
                    case 'capsula': geo = new THREE.CapsuleGeometry(0.4, 1, 8, 16); break;
                    default: geo = new THREE.BoxGeometry(1, 1, 1); break;
                }
                obj = new THREE.Mesh(geo, deserializarMaterial(data.materialData));
            }

            obj.uuid = data.uuid;
            obj.name = data.name;
            obj.position.fromArray(data.position);
            obj.rotation.fromArray(data.rotation);
            obj.scale.fromArray(data.scale);
            obj.userData.tipo = data.type;
            obj.userData.isLocked = data.isLocked || false;
            obj.userData.lastColor = data.materialData ? data.materialData.color : undefined;
            obj.userData.textureURL = data.textureURL;
            obj.userData.gltfAnimations = data.gltfAnimations || null;

            if (data.keyframes && data.keyframes.length > 0) {
                keyframes.set(obj.uuid, data.keyframes.map(k => ({
                    position: new THREE.Vector3().fromArray(k.position),
                    rotation: new THREE.Euler().fromArray(k.rotation),
                    scale: new THREE.Vector3().fromArray(k.scale)
                })));
            }

            if (data.type === 'luzPunto') {
                obj.intensity = data.lightIntensity;
                obj.distance = data.lightDistance;
                obj.color.set(data.lightColor);
            }
            
            if (data.type === 'grupo' && data.childrenUuids) {
                obj.userData.childrenUuids = data.childrenUuids;
            } else {
                // Store original material properties for normal mode and undo/redo
                obj.userData.originalMaterial = obj.material.clone();
                obj.userData.originalMaterialColor = obj.material.color ? obj.material.color.getHex() : 0xffffff;
                obj.userData.originalRoughness = obj.material.roughness;
                obj.userData.originalMetalness = obj.material.metalness;
                obj.userData.originalOpacity = obj.material.opacity;
                obj.userData.originalTransparent = obj.material.transparent;
            }

            return obj;
        }

        function guardarEscena() {
            const data = {
                objetos: objetos.map(obj => serializarObjeto(obj)),
                camaraPos: camara.position.toArray(),
                camaraTarget: controls.target.toArray(),
                riggingModeActivo: riggingModeActivo,
                ambientLightIntensity: ambientLight.intensity,
                ambientLightColor: ambientLight.color.getHex(),
                directionalLightIntensity: directionalLight.intensity,
                directionalLightColor: directionalLight.color.getHex(),
                skyboxActive: skyboxActivo,
                animationSpeed: duracionPorFrame,
                modoVisualizacion: modoVisualizacion,
                axesHelperVisible: axesHelper.visible,
                gridHelperVisible: gridHelper.visible
            };
            try {
                localStorage.setItem('infinity3d_scene', JSON.stringify(data));
                mostrarToast("💾 Escena guardada exitosamente.");
            } catch (e) {
                mostrarToast("❌ Error al guardar escena: " + e.message);
                console.error("Error al guardar escena:", e);
            }
        }

        function cargarEscena() {
            mostrarDialogoConfirmacion('cargar');
        }

        function confirmarCargarEscena() {
            try {
                const dataString = localStorage.getItem('infinity3d_scene');
                if (!dataString) {
                    mostrarToast("📂 No hay escenas guardadas.");
                    return;
                }
                reiniciarEscenaSinConfirmacion();

                const data = JSON.parse(dataString);
                
                const deserializedObjectsMap = new Map();
                data.objetos.forEach(objData => {
                    const obj = deserializarObjeto(objData);
                    escena.add(obj);
                    objetos.push(obj);
                    deserializedObjectsMap.set(obj.uuid, obj);

                    const tipo = obj.userData.tipo;
                    const match = obj.name.match(/\s(\d+)$/);
                    if (match) {
                        const num = parseInt(match[1]);
                        if (contador[tipo] < num) {
                            contador[tipo] = num;
                        }
                    }
                });

                objetos.forEach(obj => {
                    if (obj.userData.tipo === 'grupo' && obj.userData.childrenUuids) {
                        obj.userData.childrenUuids.forEach(childUuid => {
                            const child = deserializedObjectsMap.get(childUuid);
                            if (child) {
                                obj.attach(child);
                                const index = objetos.indexOf(child);
                                if (index > -1) {
                                    objetos.splice(index, 1);
                                }
                            }
                        });
                    }
                });


                actualizarLista();

                if (data.camaraPos && data.camaraTarget) {
                    camara.position.fromArray(data.camaraPos);
                    controls.target.fromArray(data.camaraTarget);
                    controls.update();
                }

                if (data.riggingModeActivo !== undefined) {
                    riggingModeCheckbox.checked = data.riggingModeActivo;
                    toggleRiggingMode(data.riggingModeActivo);
                }

                if (data.ambientLightIntensity !== undefined) {
                    ambientLight.intensity = data.ambientLightIntensity;
                    ambientLightIntensitySlider.value = data.ambientLightIntensity;
                    ambientLightIntensityLabel.textContent = data.ambientLightIntensity.toFixed(2);
                }
                if (data.ambientLightColor !== undefined) {
                    ambientLight.color.set(data.ambientLightColor);
                    ambientLightColorPicker.value = "#" + new THREE.Color(data.ambientLightColor).getHexString();
                }

                if (data.directionalLightIntensity !== undefined) {
                    directionalLight.intensity = data.directionalLightIntensity;
                    directionalLightIntensitySlider.value = data.directionalLightIntensity;
                    directionalLightIntensityLabel.textContent = data.directionalLightIntensity.toFixed(2);
                }
                if (data.directionalLightColor !== undefined) {
                    directionalLight.color.set(data.directionalLightColor);
                    directionalLightColorPicker.value = "#" + new THREE.Color(data.directionalLightColor).getHexString();
                }

                if (data.skyboxActive !== undefined) {
                    skyboxCheckbox.checked = data.skyboxActive;
                    toggleSkybox(data.skyboxActive);
                } else {
                     skyboxCheckbox.checked = true;
                     toggleSkybox(true);
                }
                
                if (data.animationSpeed !== undefined) {
                    duracionPorFrame = data.animationSpeed;
                    animSpeedSlider.value = data.animationSpeed;
                    animSpeedLabel.textContent = `${data.animationSpeed} ms/frame`;
                }

                if (data.modoVisualizacion !== undefined) {
                    establecerModoVisualizacion(data.modoVisualizacion);
                } else {
                    establecerModoVisualizacion('normal');
                }

                if (data.axesHelperVisible !== undefined) {
                    axesHelper.visible = data.axesHelperVisible;
                    axesHelperCheckbox.checked = data.axesHelperVisible;
                } else {
                    axesHelper.visible = true;
                    axesHelperCheckbox.checked = true;
                }

                if (data.gridHelperVisible !== undefined) {
                    gridHelper.visible = data.gridHelperVisible;
                    gridHelperCheckbox.checked = data.gridHelperVisible;
                } else {
                    gridHelper.visible = true;
                    gridHelperCheckbox.checked = true;
                }

                mostrarToast("✅ Escena cargada exitosamente.");
                historial.length = 0;
                indiceHistorial = -1;
                actualizarBotonesUndoRedo();
            } catch (e) {
                mostrarToast("❌ Error al cargar escena. Datos corruptos.");
                console.error("Error al cargar escena:", e);
            }
        }

        function reiniciarEscena() {
            mostrarDialogoConfirmacion('reiniciar');
        }

        function reiniciarEscenaSinConfirmacion() {
            while(objetos.length > 0){
                const obj = objetos.pop();
                escena.remove(obj);
                if (obj.userData.bboxHelper) {
                    escena.remove(obj.userData.bboxHelper);
                    obj.userData.bboxHelper.dispose();
                    obj.userData.bboxHelper = null;
                }
            }
            for (const key in contador) {
                contador[key] = 0;
            }
            objetoSeleccionado = null;
            eliminarGizmos();
            updateObjectPropertiesPanel(null); // Clear object properties
            actualizarLista();
            keyframes.clear();
            animando = false;
            camara.position.set(0, 4, 8);
            controls.target.set(0, 1, 0);
            controls.update();
            historial.length = 0;
            indiceHistorial = -1;
            actualizarBotonesUndoRedo();
            riggingModeCheckbox.checked = false;
            toggleRiggingMode(false);
            
            ambientLight.intensity = parseFloat(ambientLightIntensitySlider.value);
            ambientLightIntensityLabel.textContent = ambientLight.intensity.toFixed(2);
            ambientLight.color.set(0xffffff);
            ambientLightColorPicker.value = "#ffffff";

            directionalLight.intensity = parseFloat(directionalLightIntensitySlider.value);
            directionalLightIntensityLabel.textContent = directionalLight.intensity.toFixed(2);
            directionalLight.color.set(0xffffff);
            directionalLightColorPicker.value = "#ffffff";

            // Reset object specific properties in the panel
            updateObjectPropertiesPanel(null);

            // Reset sliders and labels for material properties
            const roughnessSlider = document.getElementById("roughnessSlider");
            const roughnessLabel = document.getElementById("roughnessLabel");
            const metalnessSlider = document.getElementById("metalnessSlider");
            const metalnessLabel = document.getElementById("metalnessLabel");
            const opacitySlider = document.getElementById("opacitySlider");
            const opacityLabel = document.getElementById("opacityLabel");
            const transparentCheckbox = document.getElementById("transparentCheckbox");
            const pointLightIntensitySlider = document.getElementById("pointLightIntensitySlider");
            const pointLightIntensityLabel = document.getElementById("pointLightIntensityLabel");
            const pointLightDistanceSlider = document.getElementById("pointLightDistanceSlider");
            const pointLightDistanceLabel = document.getElementById("pointLightDistanceLabel");
            const pointLightColorPicker = document.getElementById("pointLightColorPicker");

            if (roughnessSlider) { roughnessSlider.value = 0.5; roughnessLabel.textContent = "0.50"; }
            if (metalnessSlider) { metalnessSlider.value = 0.0; metalnessLabel.textContent = "0.00"; }
            if (opacitySlider) { opacitySlider.value = 1.0; opacityLabel.textContent = "1.00"; }
            if (transparentCheckbox) { transparentCheckbox.checked = false; }
            if (pointLightIntensitySlider) { pointLightIntensitySlider.value = 1; pointLightIntensityLabel.textContent = "1.0"; }
            if (pointLightDistanceSlider) { pointLightDistanceSlider.value = 0; pointLightDistanceLabel.textContent = "0.0 (infinita)"; }
            if (pointLightColorPicker) { pointLightColorPicker.value = "#ffffff"; }


            axesHelper.visible = true;
            axesHelperCheckbox.checked = true;
            gridHelper.visible = true;
            gridHelperCheckbox.checked = true;

            skyboxCheckbox.checked = true;
            toggleSkybox(true);

            duracionPorFrame = parseInt(animSpeedSlider.value);
            animSpeedLabel.textContent = `${duracionPorFrame} ms/frame`;

            establecerModoVisualizacion('normal');

            mostrarToast("🆕 Nueva escena creada.");
        }


        // --- Animación ---

        const keyframes = new Map();
        let animando = false, frameActual = 0, totalFrames = 0;
        let animationInterval = null;

        function agregarFrame() {
            if (!objetoSeleccionado) {
                mostrarToast("☝️ Selecciona una figura para añadir un fotograma.");
                return;
            }
            if (riggingModeActivo) {
                mostrarToast("🚫 No se pueden agregar fotogramas en Rigging Mode.");
                return;
            }
            if (objetoSeleccionado.userData.isLocked) {
                mostrarToast("🔒 Objeto bloqueado. Desbloquéalo para agregar fotogramas.");
                return;
            }
            if (objetoSeleccionado.userData.tipo === 'luzPunto' || objetoSeleccionado.userData.tipo === 'grupo') {
                mostrarToast("🚫 Las luces y los grupos no pueden tener fotogramas clave directamente.");
                return;
            }

            const id = objetoSeleccionado.uuid;
            if (!keyframes.has(id)) keyframes.set(id, []);

            keyframes.get(id).push({
                position: objetoSeleccionado.position.clone(),
                rotation: objetoSeleccionado.rotation.clone(),
                scale: objetoSeleccionado.scale.clone()
            });
            totalFrames = keyframes.get(id).length;
            updateTimelinePlayhead();
            mostrarToast(`✔️ Fotograma ${keyframes.get(id).length} agregado para ${objetoSeleccionado.name}.`);
        }

        function reproducirAnimacion() {
            if (!objetoSeleccionado) {
                mostrarToast("☝️ Selecciona una figura para animar.");
                return;
            }
            if (riggingModeActivo) {
                mostrarToast("🚫 No se puede animar en Rigging Mode.");
                return;
            }
            if (objetoSeleccionado.userData.tipo === 'luzPunto' || objetoSeleccionado.userData.tipo === 'grupo') {
                mostrarToast("🚫 Las luces y los grupos no pueden animarse directamente.");
                return;
            }
            const id = objetoSeleccionado.uuid;
            const frames = keyframes.get(id);
            if (!frames || frames.length < 2) {
                mostrarToast("⚠️ Necesitas al menos 2 fotogramas para animar.");
                return;
            }

            if (animando) {
                animando = false;
                clearInterval(animationInterval);
                mostrarToast("⏸ Animación pausada.");
            } else {
                frameActual = 0;
                totalFrames = frames.length;
                animando = true;
                mostrarToast(`▶ Animando ${objetoSeleccionado.name}...`);
                animationInterval = setInterval(() => animarFrameStep(id), duracionPorFrame);
            }
        }

        function animarFrameStep(id) {
            if (!animando) return;

            const frames = keyframes.get(id);
            if (!frames || frames.length === 0) {
                animando = false;
                clearInterval(animationInterval);
                return;
            }

            const currentFrameData = frames[frameActual % frames.length];
            objetoSeleccionado.position.copy(currentFrameData.position);
            objetoSeleccionado.rotation.copy(currentFrameData.rotation);
            objetoSeleccionado.scale.copy(currentFrameData.scale);

            updateTransformInputs(objetoSeleccionado); // Update UI inputs during animation
            updateTimelinePlayhead();

            frameActual++;
            if (frameActual >= totalFrames) {
                frameActual = 0; // Loop animation
                // If you want it to stop after one loop:
                // animando = false;
                // clearInterval(animationInterval);
                // mostrarToast("⏸ Animación finalizada.");
            }
        }

        function updateTimelinePlayhead() {
            if (totalFrames > 0) {
                const progress = (frameActual / totalFrames) * 100;
                timelinePlayhead.style.left = `${progress}%`;
            } else {
                timelinePlayhead.style.left = '0%';
            }
        }
        updateTimelinePlayhead(); // Initialize playhead position

        // --- Exportar Video ---

        function exportarVideo() {
            if (!window.MediaRecorder) {
                mostrarToast("❌ Tu navegador no soporta la grabación de video.");
                return;
            }
            if (!objetoSeleccionado || !keyframes.has(objetoSeleccionado.uuid) || keyframes.get(objetoSeleccionado.uuid).length < 2) {
                mostrarToast("⚠️ Necesitas una figura con al menos 2 fotogramas para exportar.");
                return;
            }
            if (riggingModeActivo) {
                mostrarToast("🚫 No se puede exportar video en Rigging Mode.");
                return;
            }
            if (objetoSeleccionado.userData.isLocked) {
                mostrarToast("🔒 Objeto bloqueado. Desbloquéalo para exportar video.");
                return;
            }
            if (objetoSeleccionado.userData.tipo === 'luzPunto' || objetoSeleccionado.userData.tipo === 'grupo') {
                mostrarToast("🚫 Las luces y los grupos no pueden exportarse como video de animación directamente.");
                return;
            }

            const stream = render.domElement.captureStream(30);
            const grabador = new MediaRecorder(stream);
            const partes = [];

            grabador.ondataavailable = e => partes.push(e.data);
            grabador.onstop = () => {
                const blob = new Blob(partes, { type: "video/webm" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = "Infinity3D_Animacion.webm";
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                mostrarToast("✅ Video exportado.");
            };

            const originalAnimandoState = animando;
            const originalFrameActual = frameActual;
            const originalAnimationInterval = animationInterval;

            // Reset animation state for recording
            animando = true;
            frameActual = 0;
            clearInterval(animationInterval);
            updateTimelinePlayhead();

            grabador.start();
            mostrarToast("🎥 Grabando animación...");
            const duracionTotalAnimacion = (totalFrames) * duracionPorFrame; // Record all frames once

            let recordFrameInterval = setInterval(() => {
                animarFrameStep(objetoSeleccionado.uuid);
                if (frameActual >= totalFrames) {
                    clearInterval(recordFrameInterval);
                    if (grabador.state !== "inactive") {
                        grabador.stop();
                    }
                    // Restore original animation state
                    animando = originalAnimandoState;
                    frameActual = originalFrameActual;
                    animationInterval = originalAnimationInterval;
                    if (animando) {
                        animationInterval = setInterval(() => animarFrameStep(objetoSeleccionado.uuid), duracionPorFrame);
                    }
                    updateTimelinePlayhead();
                }
            }, duracionPorFrame);
        }

        function exportarImagen() {
            try {
                render.render(escena, camara);
                const imageDataURL = render.domElement.toDataURL('image/png');
                
                const a = document.createElement('a');
                a.href = imageDataURL;
                a.download = 'Infinity3D_Captura.png';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                mostrarToast("🖼️ Imagen exportada.");
            } catch (e) {
                mostrarToast("❌ Error al exportar imagen.");
                console.error("Error al exportar imagen:", e);
            }
        }


        // --- Pantalla Completa ---
        function activarPantallaCompleta() {
            const elem = document.documentElement;
            if (elem.requestFullscreen) {
                elem.requestFullscreen();
            } else if (elem.webkitRequestFullscreen) {
                elem.webkitRequestFullscreen();
            }
            mostrarToast("⛶ Modo Pantalla Completa");
        }

        // --- Diálogos de Confirmación ---
        function mostrarDialogoConfirmacion(accion, obj = null) {
            accionConfirmacion = { type: accion, obj: obj };
            dialogoConfirmacion.style.display = 'flex';

            switch (accion) {
                case 'reiniciar':
                    dialogoTitulo.textContent = 'Reiniciar Escena';
                    dialogoMensaje.textContent = '¿Nueva escena? ¡Se perderán los cambios no guardados!';
                    break;
                case 'cargar':
                    dialogoTitulo.textContent = 'Cargar Escena';
                    dialogoMensaje.textContent = '¿Cargar escena guardada? ¡La actual se perderá!';
                    break;
                case 'eliminar':
                    dialogoTitulo.textContent = 'Eliminar Figura';
                    dialogoMensaje.textContent = `¿Eliminar ${obj.name}? ¡No se puede deshacer!`;
                    break;
            }
        }

        btnDialogoSi.onclick = () => {
            dialogoConfirmacion.style.display = 'none';
            if (accionConfirmacion) {
                switch (accionConfirmacion.type) {
                    case 'reiniciar':
                        reiniciarEscenaSinConfirmacion();
                        break;
                    case 'cargar':
                        confirmarCargarEscena();
                        break;
                    case 'eliminar':
                        confirmarEliminar(accionConfirmacion.obj);
                        break;
                }
                accionConfirmacion = null;
            }
        };

        btnDialogoNo.onclick = () => {
            dialogoConfirmacion.style.display = 'none';
            accionConfirmacion = null;
            mostrarToast("🚫 Acción cancelada.");
        };

        // --- Bucle de Renderizado ---
        function bucle() {
            requestAnimationFrame(bucle);
            controls.update();
            if (modoVisualizacion === 'bbox') {
                objetos.forEach(obj => {
                    if (obj.userData.bboxHelper) {
                        obj.userData.bboxHelper.update();
                    }
                });
            }
            render.render(escena, camara);
        }

        bucle();
    </script>
</body>
</html>

