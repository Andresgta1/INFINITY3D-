<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Infinity3D Mobile - Compacto (Gizmos Mejorados)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100%;
            height: 100%;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000;
            touch-action: none; /* Previene el comportamiento de desplazamiento por defecto */
            user-select: none; /* Deshabilita la selecci√≥n de texto */
            -webkit-tap-highlight-color: transparent; /* Elimina el resplandor de toque en iOS */
        }

        #barra-inferior, #barra-superior {
            position: fixed;
            left: 0;
            right: 0;
            background: #1a1a1a;
            display: flex;
            flex-wrap: wrap; /* Permite que los botones se envuelvan si hay muchos */
            justify-content: center;
            gap: 3px; /* Espacio MUY reducido entre botones */
            padding: 3px; /* Padding MUY reducido */
            z-index: 100;
            box-shadow: 0 -2px 8px rgba(0,0,0,0.4);
        }

        #barra-inferior {
            bottom: 0;
        }

        #barra-superior {
            top: 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.4);
        }

        .boton, .boton-menu {
            background: #333;
            color: white;
            border: none;
            padding: 6px 10px; /* Padding MUY compacto */
            border-radius: 15px; /* Bordes m√°s redondeados */
            font-size: 11px; /* Fuente M√ÅS peque√±a */
            cursor: pointer;
            transition: background 0.2s ease, transform 0.1s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 3px; /* Espacio M√ÅS reducido para √≠conos/texto */
            white-space: nowrap; /* Evita que el texto del bot√≥n se rompa */
        }

        .boton:hover, .boton-menu:hover {
            background: #555;
        }

        .boton:active, .boton-menu:active {
            transform: scale(0.98);
        }

        canvas {
            position: absolute;
            left: 0;
            /* La altura y el 'top' se establecer√°n con JavaScript para llenar el espacio */
        }

        /* Paneles flotantes */
        .panel {
            position: fixed;
            background: rgba(40, 40, 40, 0.9); /* Fondo un poco menos opaco */
            color: white;
            padding: 8px; /* Padding MUY reducido */
            border-radius: 8px; /* M√°s compacto */
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            z-index: 200;
            display: none;
            backdrop-filter: blur(3px); /* Desenfoque sutil */
            -webkit-backdrop-filter: blur(3px);
        }

        #colorBox {
            top: 50px; /* Ajustado para no colisionar con la barra superior */
            right: 5px; /* Posici√≥n compacta */
            width: 160px; /* M√°s estrecho */
            padding: 6px; /* Ajustado */
        }

        #colorPicker {
            width: 100%;
            height: 30px; /* M√°s compacto */
        }

        /* Estilos espec√≠ficos para AmbientLightPicker */
        #ambientLightColorPicker, #pointLightColorPicker {
            width: 100%;
            height: 30px; /* M√°s compacto */
            margin-top: 3px; /* Margen reducido */
        }

        #configBox {
            top: 50px; /* Ajustado */
            left: 5px; /* Posici√≥n compacta */
            width: 200px; /* M√°s estrecho para m√°s controles */
            padding: 6px; /* Ajustado */
        }

        #configBox label {
            margin-bottom: 3px; /* Margen MUY reducido */
            font-size: 12px; /* M√°s peque√±o */
            display: block; /* Asegura que cada label est√© en su propia l√≠nea */
        }

        #configBox input[type="range"] {
            width: 100%; /* Asegura que ocupa todo el ancho */
            height: 5px; /* M√°s delgado */
            margin-bottom: 6px; /* Espacio debajo del slider */
        }

        #configBox input[type="range"]::-webkit-slider-thumb {
            width: 16px; /* M√°s peque√±o */
            height: 16px; /* M√°s peque√±o */
        }

        #configBox input[type="range"]::-moz-range-thumb {
            width: 16px; /* M√°s peque√±o */
            height: 16px; /* M√°s peque√±o */
        }
        
        #configBox .checkbox-container {
            display: flex;
            align-items: center;
            margin-bottom: 8px; /* Reducido */
            gap: 4px; /* Reducido */
        }

        #configBox .checkbox-container input[type="checkbox"] {
            width: 16px;
            height: 16px;
            margin-right: 3px;
            cursor: pointer;
        }

        #velocidadLabel, #animSpeedLabel, #ambientLightIntensityLabel, #pointLightIntensityLabel, #pointLightDistanceLabel {
            font-size: 11px; /* M√°s peque√±o */
        }

        /* --- Estilos para Outliner/Lista de Figuras --- */
        #listaBox {
            top: 100px; /* Ajustado para no chocar y ser m√°s compacto */
            left: 5px;
            max-height: 200px; /* M√°x. altura reducida */
            width: 200px; /* M√°s estrecho */
            padding: 0;
            overflow-y: auto; /* Para scroll si hay muchos elementos */
        }

        #listaBox h3 {
            padding: 6px 8px; /* Reducido */
            font-size: 14px; /* M√°s peque√±o */
            margin: 0;
            border-bottom: 1px solid #444;
            background: #2a2a2a; /* Fondo para el t√≠tulo */
            position: sticky; /* Sticky header */
            top: 0;
            z-index: 1;
        }

        .itemLista {
            padding: 6px 8px; /* Reducido */
            font-size: 12px; /* M√°s peque√±o */
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #333;
            cursor: pointer;
            position: relative; /* Para el input de renombrar */
        }
        .itemLista:last-child {
            border-bottom: none;
        }
        .itemLista:hover {
            background: #555;
        }
        .itemLista.seleccionado {
            background: #007bff;
            font-weight: bold;
        }
        .itemLista.bloqueado {
            opacity: 0.6;
            cursor: not-allowed;
        }
        .itemLista.bloqueado .botones-item button {
            pointer-events: none;
            opacity: 0.5;
        }

        .itemLista .nombre-item {
            flex-grow: 1; /* Ocupa el espacio disponible */
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis; /* Puntos suspensivos si el nombre es muy largo */
        }

        .itemLista .botones-item {
            display: flex;
            gap: 3px; /* Reducido */
            margin-left: 4px; /* Reducido */
        }

        .boton-eliminar-item, .boton-renombrar-item, .boton-bloquear-item {
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 2px 5px; /* M√°s peque√±o */
            font-size: 10px; /* M√°s peque√±o */
            cursor: pointer;
            line-height: 1; /* Asegura que el texto est√© centrado */
        }
        .boton-eliminar-item:hover {
            background: #c82333;
        }
        .boton-renombrar-item {
            background: #28a745; /* Color verde para renombrar */
        }
        .boton-renombrar-item:hover {
            background: #218838;
        }
        .boton-bloquear-item {
            background: #ffc107; /* Amarillo para bloquear */
            color: #333;
        }
        .boton-bloquear-item.activo { /* Cuando est√° bloqueado */
            background: #17a2b8; /* Azul claro */
            color: white;
        }
        .boton-bloquear-item:hover {
            background: #e0a800;
        }


        .itemLista input[type="text"] {
            background: #444;
            color: white;
            border: 1px solid #666;
            padding: 3px; /* M√°s peque√±o */
            font-size: 12px; /* M√°s peque√±o */
            border-radius: 3px;
            width: calc(100% - 8px); /* Ajusta el ancho */
            box-sizing: border-box; /* Incluye padding y border en el width */
            position: absolute;
            left: 4px;
            top: 50%;
            transform: translateY(-50%);
            display: none; /* Oculto por defecto */
        }

        /* Toast/Notificaci√≥n */
        #toast {
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            bottom: 55px; /* Encima de la barra inferior (ajustado) */
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 12px; /* Reducido */
            border-radius: 5px; /* M√°s peque√±o */
            font-size: 12px; /* M√°s peque√±o */
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
            z-index: 1000;
            white-space: nowrap;
        }
        #toast.mostrar {
            opacity: 1;
            visibility: visible;
        }

        /* Overlays y di√°logos */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 500;
            display: none; /* Oculto por defecto */
        }

        .dialogo {
            background: #282828;
            color: white;
            padding: 15px; /* Reducido */
            border-radius: 6px; /* M√°s compacto */
            text-align: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.6);
            max-width: 90%; /* Ajuste para m√≥viles */
        }

        .dialogo h3 {
            margin-bottom: 10px; /* Reducido */
            font-size: 16px; /* M√°s peque√±o */
            color: #eee;
        }

        .dialogo p {
            margin-bottom: 15px;
            font-size: 13px;
        }

        .dialogo-botones button {
            background: #007bff;
            color: white;
            border: none;
            padding: 6px 12px; /* Reducido */
            border-radius: 5px; /* M√°s compacto */
            font-size: 12px; /* M√°s peque√±o */
            cursor: pointer;
            margin: 0 6px; /* Reducido */
            transition: background 0.2s ease;
        }
        .dialogo-botones button:hover {
            background: #0056b3;
        }
        .dialogo-botones button:last-child {
            background: #6c757d;
        }
        .dialogo-botones button:last-child:hover {
            background: #5a6268;
        }

        /* Estilos para los modos de transformaci√≥n */
        .modo-transformacion {
            display: flex;
            justify-content: space-around;
            margin-top: 8px; /* Reducido */
            gap: 4px; /* Espacio reducido */
        }

        .modo-transformacion button {
            flex-grow: 1;
            padding: 5px 8px; /* Reducido */
            border-radius: 5px; /* M√°s compacto */
            font-size: 11px; /* M√°s peque√±o */
            background: #444;
        }
        .modo-transformacion button.activo {
            background: #007bff;
            font-weight: bold;
        }

        /* Estilos para los modos de visualizaci√≥n */
        .modo-visualizacion {
            display: flex;
            justify-content: space-around;
            margin-top: 8px; /* Reducido */
            gap: 4px; /* Reducido */
        }
        .modo-visualizacion button {
            flex-grow: 1;
            padding: 5px 8px; /* Reducido */
            border-radius: 5px; /* Reducido */
            font-size: 11px; /* M√°s peque√±o */
            background: #444;
        }
        .modo-visualizacion button.activo {
            background: #007bff;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="barra-superior">
        <button class="boton" onclick="mostrarPanel('configBox')">‚öôÔ∏è Config</button>
        <button class="boton" onclick="activarPantallaCompleta()">‚õ∂ Fullscreen</button>
        <button class="boton" onclick="guardarEscena()">üíæ Guardar</button>
        <button class="boton" onclick="cargarEscena()">üìÇ Cargar</button>
        <button class="boton" onclick="reiniciarEscena()">üîÑ Nueva</button>
        <button class="boton" onclick="deshacerAccion()" id="btnDeshacer">‚Ü© Deshacer</button>
        <button class="boton" onclick="rehacerAccion()" id="btnRehacer">‚Ü™ Rehacer</button>
    </div>

    <canvas id="renderCanvas"></canvas>

    <div id="barra-inferior">
        <button class="boton" onclick="agregarFigura('cubo')">+ Cubo</button>
        <button class="boton" onclick="agregarFigura('esfera')">+ Esfera</button>
        <button class="boton" onclick="agregarFigura('cono')">+ Cono</button>
        <button class="boton" onclick="agregarFigura('cilindro')">+ Cilindro</button>
        <button class="boton" onclick="agregarLuzPunto()">üí°+ Luz</button>
        <button class="boton" onclick="duplicarFigura()">üìã Duplicar</button>
        <button class="boton" onclick="agruparObjetos()">üîó Agrupar</button>
        <button class="boton" onclick="desagruparObjetos()">üíî Desagrupar</button>
        <button class="boton" onclick="resetearTransformacion()">‚ôªÔ∏è Resetear</button>
        <button class="boton" onclick="abrirImportadorModelo()">üì• Modelo</button>
        <button class="boton" onclick="abrirImportadorTextura()">üèûÔ∏è Textura</button>
        <button class="boton" onclick="centrarFigura()">üéØ Centrar</button>
        <button class="boton" onclick="mostrarPanel('listaBox')">üìã Outliner</button>
        <button class="boton" onclick="agregarFrame()">+ Frame</button>
        <button class="boton" onclick="reproducirAnimacion()">‚ñ∂ Animar</button>
        <button class="boton" onclick="exportarVideo()">üé• Exportar Video</button>
        <button class="boton" onclick="exportarImagen()">üñºÔ∏è Exportar Imagen</button>
    </div>

    <div id="colorBox" class="panel">
        <label>üé® Color Objeto:</label>
        <input type="color" id="colorPicker" />
    </div>

    <div id="configBox" class="panel">
        <label>‚öôÔ∏è Vel. Movimiento:</label>
        <input type="range" id="velocidadSlider" min="0.01" max="0.2" step="0.01" value="0.05">
        <span id="velocidadLabel">0.05</span>
        <hr style="border-color: #444; margin: 8px 0;">
        <label>‚ö° Vel. Animaci√≥n:</label>
        <input type="range" id="animSpeedSlider" min="100" max="2000" step="50" value="700">
        <span id="animSpeedLabel">700 ms/frame</span>
        <hr style="border-color: #444; margin: 8px 0;">
        <label>üí° Luz Ambiental (Intensidad):</label>
        <input type="range" id="ambientLightIntensitySlider" min="0" max="2" step="0.01" value="0.8">
        <span id="ambientLightIntensityLabel">0.8</span>
        <label>üí° Luz Ambiental (Color):</label>
        <input type="color" id="ambientLightColorPicker" value="#ffffff">
        <hr style="border-color: #444; margin: 8px 0;">
        <label>üí° Luz de Punto (Intensidad):</label>
        <input type="range" id="pointLightIntensitySlider" min="0" max="5" step="0.1" value="1">
        <span id="pointLightIntensityLabel">1.0</span>
        <label>üí° Luz de Punto (Distancia):</label>
        <input type="range" id="pointLightDistanceSlider" min="0" max="20" step="0.5" value="0">
        <span id="pointLightDistanceLabel">0.0 (infinita)</span>
        <label>üí° Luz de Punto (Color):</label>
        <input type="color" id="pointLightColorPicker" value="#ffffff">
        <hr style="border-color: #444; margin: 8px 0;">
        <div class="checkbox-container">
            <label for="skyboxCheckbox">üèûÔ∏è Skybox:</label>
            <input type="checkbox" id="skyboxCheckbox" checked onchange="toggleSkybox(this.checked)">
        </div>
        <hr style="border-color: #444; margin: 8px 0;">
        <label>üéö Modo Transformaci√≥n:</label>
        <div class="modo-transformacion">
            <button id="btnModoTrasladar" onclick="establecerModoTransformacion('trasladar')" class="activo">Mover</button>
            <button id="btnModoRotar" onclick="establecerModoTransformacion('rotar')">Rotar</button>
            <button id="btnModoEscalar" onclick="establecerModoTransformacion('escalar')">Escalar</button>
        </div>
        <hr style="border-color: #444; margin: 8px 0;">
        <label>üëÅÔ∏è Modo Visualizaci√≥n:</label>
        <div class="modo-visualizacion">
            <button id="btnModoNormal" onclick="establecerModoVisualizacion('normal')" class="activo">Normal</button>
            <button id="btnModoWireframe" onclick="establecerModoVisualizacion('wireframe')">Alambre</button>
            <button id="btnModoBoundingBox" onclick="establecerModoVisualizacion('bbox')">Caja Delim.</button>
        </div>
        <hr style="border-color: #444; margin: 8px 0;">
        <div class="checkbox-container">
            <label for="riggingModeCheckbox">ü¶¥ Rigging Mode:</label>
            <input type="checkbox" id="riggingModeCheckbox" onchange="toggleRiggingMode(this.checked)">
        </div>
    </div>

    <div id="listaBox" class="panel">
        <h3>üìã Outliner</h3>
        <div id="listaContenido"></div>
    </div>

    <div id="toast"></div>

    <div id="dialogoConfirmacion" class="overlay">
        <div class="dialogo">
            <h3 id="dialogoTitulo"></h3>
            <p id="dialogoMensaje"></p>
            <div class="dialogo-botones">
                <button id="btnDialogoSi">S√≠</button>
                <button id="btnDialogoNo">No</button>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/loaders/CubeTextureLoader.js"></script>
    <script>
        // Inicializaci√≥n de THREE.js
        const escena = new THREE.Scene();
        const camara = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        // Ahora seleccionamos el canvas por su ID
        const render = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true, canvas: document.getElementById('renderCanvas') });
        // Ya no necesitamos appendChild porque el canvas ya est√° en el DOM

        const controls = new THREE.OrbitControls(camara, render.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = true;
        controls.enablePan = true;
        controls.minDistance = 2;
        controls.maxDistance = 100;
        controls.target.set(0, 1, 0);

        // Luz Ambiental
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        escena.add(ambientLight);
        // Luz direccional ya existente
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
        directionalLight.position.set(5, 10, 7.5).normalize();
        escena.add(directionalLight);

        const gridHelper = new THREE.GridHelper(10, 10);
        escena.add(gridHelper);

        // Skybox
        let skyboxMesh = null;
        let skyboxActivo = true; // Estado inicial del skybox

        function cargarSkybox(enable = true) {
            if (skyboxMesh) {
                escena.remove(skyboxMesh);
                skyboxMesh.geometry.dispose();
                skyboxMesh.material.dispose();
                skyboxMesh = null;
                escena.background = null; // Quita el fondo de la escena
            }

            if (!enable) {
                skyboxActivo = false;
                return;
            }

            skyboxActivo = true;
            const loader = new THREE.CubeTextureLoader();
            const texturePaths = [
                'https://threejs.org/examples/textures/cube/Bridge2/posx.jpg',
                'https://threejs.org/examples/textures/cube/Bridge2/negx.jpg',
                'https://threejs.org/examples/textures/cube/Bridge2/posy.jpg',
                'https://threejs.org/examples/textures/cube/Bridge2/negy.jpg',
                'https://threejs.org/examples/textures/cube/Bridge2/posz.jpg',
                'https://threejs.org/examples/textures/cube/Bridge2/negz.jpg'
            ];

            loader.load(texturePaths, (texture) => {
                escena.background = texture;
                mostrarToast("üèûÔ∏è Skybox cargado.");
            }, undefined, (err) => {
                console.error('Error al cargar skybox:', err);
                mostrarToast("‚ùå Error al cargar Skybox.");
                skyboxCheckbox.checked = false; // Desactivar si falla
                skyboxActivo = false;
                escena.background = null; // Asegurarse de que no haya un fondo roto
            });
        }
        cargarSkybox(true); // Cargar skybox por defecto al inicio

        function toggleSkybox(checked) {
            cargarSkybox(checked);
            if (!checked) {
                escena.background = null;
            }
            mostrarToast(`Skybox: ${checked ? 'Activado' : 'Desactivado'}`);
            registrarAccion({ type: 'skybox', newState: checked }); // Registrar para Undo/Redo
        }


        function ajustarCanvasSize() {
            const barSuperiorHeight = document.getElementById('barra-superior').offsetHeight;
            const barInferiorHeight = document.getElementById('barra-inferior').offsetHeight;
            const availableHeight = window.innerHeight - barSuperiorHeight - barInferiorHeight;

            render.setSize(window.innerWidth, availableHeight);
            render.domElement.style.top = barSuperiorHeight + 'px';
            render.domElement.style.height = availableHeight + 'px';

            camara.aspect = window.innerWidth / availableHeight;
            camara.updateProjectionMatrix();
        }

        window.addEventListener("resize", ajustarCanvasSize);
        window.addEventListener("load", ajustarCanvasSize);
        ajustarCanvasSize();

        camara.position.set(0, 4, 8);

        const objetos = [];
        // NUEVO: Array para objetos seleccionados (para agrupar/desagrupar)
        const objetosSeleccionadosMultiples = [];
        const contador = { cubo: 0, esfera: 0, cono: 0, cilindro: 0, modelo: 0, luzPunto: 0, grupo: 0 };
        const raycaster = new THREE.Raycaster();
        const puntero = new THREE.Vector2();
        let previousTouchPos = new THREE.Vector2();

        let objetoSeleccionado = null;
        let gizmos = [];
        let modoTransformacion = 'trasladar';
        let modoVisualizacion = 'normal'; // NUEVO: Modo de visualizaci√≥n

        let riggingModeActivo = false;

        const colorBox = document.getElementById("colorBox");
        const colorPicker = document.getElementById("colorPicker");
        const slider = document.getElementById("velocidadSlider");
        const velLabel = document.getElementById("velocidadLabel");
        const listaBox = document.getElementById("listaBox");
        const listaContenido = document.getElementById("listaContenido");
        const toast = document.getElementById("toast");
        const riggingModeCheckbox = document.getElementById("riggingModeCheckbox");
        
        // Controles de configuraci√≥n
        const animSpeedSlider = document.getElementById("animSpeedSlider");
        const animSpeedLabel = document.getElementById("animSpeedLabel");
        const ambientLightIntensitySlider = document.getElementById("ambientLightIntensitySlider");
        const ambientLightIntensityLabel = document.getElementById("ambientLightIntensityLabel");
        const ambientLightColorPicker = document.getElementById("ambientLightColorPicker");
        const skyboxCheckbox = document.getElementById("skyboxCheckbox");
        // NUEVOS CONTROLES DE LUZ DE PUNTO
        const pointLightIntensitySlider = document.getElementById("pointLightIntensitySlider");
        const pointLightIntensityLabel = document.getElementById("pointLightIntensityLabel");
        const pointLightDistanceSlider = document.getElementById("pointLightDistanceSlider");
        const pointLightDistanceLabel = document.getElementById("pointLightDistanceLabel");
        const pointLightColorPicker = document.getElementById("pointLightColorPicker");


        let velocidadMovimiento = parseFloat(slider.value);
        let duracionPorFrame = parseInt(animSpeedSlider.value);

        slider.addEventListener("input", () => {
            velocidadMovimiento = parseFloat(slider.value);
            velLabel.textContent = velocidadMovimiento.toFixed(2);
        });

        animSpeedSlider.addEventListener("input", () => {
            duracionPorFrame = parseInt(animSpeedSlider.value);
            animSpeedLabel.textContent = `${duracionPorFrame} ms/frame`;
        });

        ambientLightIntensitySlider.addEventListener("input", () => {
            const oldIntensity = ambientLight.intensity;
            ambientLight.intensity = parseFloat(ambientLightIntensitySlider.value);
            ambientLightIntensityLabel.textContent = ambientLight.intensity.toFixed(2);
            registrarAccion({ type: 'ambientIntensity', oldIntensity: oldIntensity, newIntensity: ambientLight.intensity });
        });

        ambientLightColorPicker.addEventListener("input", () => {
            const oldColor = ambientLight.color.getHex();
            ambientLight.color.set(ambientLightColorPicker.value);
            registrarAccion({ type: 'ambientColor', oldColor: oldColor, newColor: ambientLight.color.getHex() });
        });

        // NUEVO: Listeners para los controles de Luz de Punto
        pointLightIntensitySlider.addEventListener("input", () => {
            // Aplica el cambio a la luz de punto seleccionada si existe
            if (objetoSeleccionado && objetoSeleccionado.userData.tipo === 'luzPunto') {
                const oldIntensity = objetoSeleccionado.intensity;
                objetoSeleccionado.intensity = parseFloat(pointLightIntensitySlider.value);
                pointLightIntensityLabel.textContent = objetoSeleccionado.intensity.toFixed(1);
                registrarAccion({ type: 'lightIntensity', objectId: objetoSeleccionado.uuid, oldIntensity: oldIntensity, newIntensity: objetoSeleccionado.intensity });
            } else {
                pointLightIntensityLabel.textContent = parseFloat(pointLightIntensitySlider.value).toFixed(1);
            }
        });

        pointLightDistanceSlider.addEventListener("input", () => {
            if (objetoSeleccionado && objetoSeleccionado.userData.tipo === 'luzPunto') {
                const oldDistance = objetoSeleccionado.distance;
                objetoSeleccionado.distance = parseFloat(pointLightDistanceSlider.value);
                pointLightDistanceLabel.textContent = objetoSeleccionado.distance.toFixed(1) + (objetoSeleccionado.distance === 0 ? " (infinita)" : "");
                registrarAccion({ type: 'lightDistance', objectId: objetoSeleccionado.uuid, oldDistance: oldDistance, newDistance: objetoSeleccionado.distance });
            } else {
                pointLightDistanceLabel.textContent = parseFloat(pointLightDistanceSlider.value).toFixed(1) + (parseFloat(pointLightDistanceSlider.value) === 0 ? " (infinita)" : "");
            }
        });

        pointLightColorPicker.addEventListener("input", () => {
            if (objetoSeleccionado && objetoSeleccionado.userData.tipo === 'luzPunto') {
                const oldColor = objetoSeleccionado.color.getHex();
                objetoSeleccionado.color.set(pointLightColorPicker.value);
                registrarAccion({ type: 'lightColor', objectId: objetoSeleccionado.uuid, oldColor: oldColor, newColor: objetoSeleccionado.color.getHex() });
            }
        });


        const dialogoConfirmacion = document.getElementById('dialogoConfirmacion');
        const dialogoTitulo = document.getElementById('dialogoTitulo');
        const dialogoMensaje = document.getElementById('dialogoMensaje');
        const btnDialogoSi = document.getElementById('btnDialogoSi');
        const btnDialogoNo = document.getElementById('btnDialogoNo');
        let accionConfirmacion = null;

        let puntoInterseccionInicial3D = new THREE.Vector3();

        // --- Funciones de Interfaz de Usuario ---

        function mostrarToast(mensaje, duracion = 3000) {
            toast.textContent = mensaje;
            toast.classList.add("mostrar");
            setTimeout(() => {
                toast.classList.remove("mostrar");
            }, duracion);
        }

        function mostrarPanel(panelId) {
            const panel = document.getElementById(panelId);
            document.querySelectorAll('.panel').forEach(p => {
                if (p.id !== panelId) p.style.display = 'none';
            });
            panel.style.display = panel.style.display === "block" ? "none" : "block";
            if (panelId === 'listaBox' && panel.style.display === 'block') {
                actualizarLista();
            }
        }

        function mostrarColorPicker(obj) {
            if (obj && obj.material && obj.material.color) {
                colorPicker.value = "#" + obj.material.color.getHexString();
                colorBox.style.display = "block";
                colorPicker.oninput = () => {
                    const oldColor = obj.material.color.getHex();
                    obj.material.color.set(colorPicker.value);
                    const newColor = obj.material.color.getHex();
                    if (oldColor !== newColor) {
                        registrarAccion({ type: 'color', objectId: obj.uuid, oldColor: oldColor, newColor: newColor });
                    }
                };
            } else {
                ocultarColorPicker();
            }
        }

        function ocultarColorPicker() {
            colorBox.style.display = "none";
        }

        function actualizarBotonesTransformacion() {
            document.querySelectorAll('.modo-transformacion button').forEach(btn => {
                btn.classList.remove('activo');
            });
            document.getElementById(`btnModo${modoTransformacion.charAt(0).toUpperCase() + modoTransformacion.slice(1)}`).classList.add('activo');
        }

        function establecerModoTransformacion(modo) {
            modoTransformacion = modo;
            actualizarBotonesTransformacion();
            if (objetoSeleccionado) {
                crearGizmos(objetoSeleccionado);
            }
            mostrarToast(`Modo: ${modo.charAt(0).toUpperCase() + modo.slice(1)}`);
        }
        establecerModoTransformacion('trasladar');

        // NUEVO: Funciones para modos de visualizaci√≥n
        function actualizarBotonesVisualizacion() {
            document.querySelectorAll('.modo-visualizacion button').forEach(btn => {
                btn.classList.remove('activo');
            });
            const btnId = `btnModo${modoVisualizacion.charAt(0).toUpperCase() + modoVisualizacion.slice(1)}`;
            const btn = document.getElementById(btnId);
            if (btn) btn.classList.add('activo');
        }

        function establecerModoVisualizacion(modo) {
            modoVisualizacion = modo;
            actualizarBotonesVisualizacion();
            aplicarModoVisualizacionAObjetos();
            mostrarToast(`Visualizaci√≥n: ${modo.charAt(0).toUpperCase() + modo.slice(1)}`);
        }
        establecerModoVisualizacion('normal'); // Modo normal por defecto

        function aplicarModoVisualizacionAObjetos() {
            objetos.forEach(obj => {
                // Solo aplica a objetos con geometr√≠a y material
                if (obj.isMesh && obj.material) {
                    // Guarda el material original si no se ha guardado ya
                    if (!obj.userData.originalMaterial) {
                        obj.userData.originalMaterial = obj.material;
                        obj.userData.originalMaterialColor = obj.material.color ? obj.material.color.getHex() : 0xffffff;
                    }

                    if (obj.userData.tipo === 'luzPunto') { // Las luces no cambian de visualizaci√≥n
                        obj.material = obj.userData.originalMaterial;
                        return;
                    }

                    switch (modoVisualizacion) {
                        case 'normal':
                            obj.material = obj.userData.originalMaterial;
                            if (obj.material.color) obj.material.color.set(obj.userData.originalMaterialColor); // Restaura el color original
                            obj.material.wireframe = false;
                            if (obj.userData.bboxHelper) {
                                escena.remove(obj.userData.bboxHelper);
                                obj.userData.bboxHelper.dispose();
                                obj.userData.bboxHelper = null;
                            }
                            break;
                        case 'wireframe':
                            // Si el material original ya es wireframe, √∫salo. Si no, crea uno nuevo.
                            if (!obj.userData.wireframeMaterial) {
                                obj.userData.wireframeMaterial = new THREE.MeshBasicMaterial({
                                    color: obj.userData.originalMaterialColor || 0x00ff00, // Usa el color original o verde
                                    wireframe: true
                                });
                            }
                            obj.material = obj.userData.wireframeMaterial;
                            if (obj.userData.bboxHelper) {
                                escena.remove(obj.userData.bboxHelper);
                                obj.userData.bboxHelper.dispose();
                                obj.userData.bboxHelper = null;
                            }
                            break;
                        case 'bbox':
                            obj.material = obj.userData.originalMaterial; // Vuelve al material normal
                            obj.material.wireframe = false;
                            if (!obj.userData.bboxHelper) {
                                obj.userData.bboxHelper = new THREE.BoxHelper(obj, 0xffff00); // Color amarillo
                                escena.add(obj.userData.bboxHelper);
                            }
                            break;
                    }
                    obj.material.needsUpdate = true;
                }
            });
            // Aseg√∫rate de que los helpers de Bounding Box se actualicen
            if (modoVisualizacion === 'bbox') {
                objetos.forEach(obj => {
                    if (obj.userData.bboxHelper) {
                        obj.userData.bboxHelper.update();
                    }
                });
            }
        }


        function toggleRiggingMode(activo) {
            riggingModeActivo = activo;
            mostrarToast(`Rigging Mode: ${riggingModeActivo ? 'Activado' : 'Desactivado'}`);

            if (riggingModeActivo) {
                eliminarGizmos();
                if (objetoSeleccionado && objetoSeleccionado.isSkinnedMesh) {
                    mostrarToast("Modo Rigging: Haz clic en los huesos para manipularlos.");
                    objetoSeleccionado.skeleton.bones.forEach(bone => {
                        const boneHelper = new THREE.AxesHelper(0.1);
                        bone.add(boneHelper);
                    });
                    escena.add(new THREE.SkeletonHelper(objetoSeleccionado.skeleton));
                }
            } else {
                if (objetoSeleccionado) {
                    crearGizmos(objetoSeleccionado);
                }
                escena.children.forEach(child => {
                    if (child instanceof THREE.SkeletonHelper) {
                        escena.remove(child);
                    }
                });
                if (objetoSeleccionado && objetoSeleccionado.isSkinnedMesh) {
                    objetoSeleccionado.skeleton.bones.forEach(bone => {
                        const helpers = bone.children.filter(c => c instanceof THREE.AxesHelper);
                        helpers.forEach(h => bone.remove(h));
                    });
                }
            }
        }


        // --- Funciones de Gesti√≥n de Escena y Objetos ---

        function agregarFigura(tipo) {
            let geo;
            let initialScale = new THREE.Vector3(1, 1, 1);
            switch (tipo) {
                case 'cubo': geo = new THREE.BoxGeometry(1, 1, 1); break;
                case 'esfera': geo = new THREE.SphereGeometry(0.6, 32, 16); break;
                case 'cono': geo = new THREE.ConeGeometry(0.5, 1.2, 32); break;
                case 'cilindro': geo = new THREE.CylinderGeometry(0.5, 0.5, 1.2, 32); break;
                default: return;
            }
            const mat = new THREE.MeshStandardMaterial({ color: Math.random() * 0xffffff });
            const figura = new THREE.Mesh(geo, mat);
            figura.position.set(Math.random() * 3 - 1.5, 0.6, Math.random() * 3 - 1.5);
            contador[tipo]++;
            figura.name = tipo.charAt(0).toUpperCase() + tipo.slice(1) + " " + contador[tipo];
            figura.userData.tipo = tipo;
            figura.userData.initialPosition = figura.position.clone();
            figura.userData.initialRotation = figura.rotation.clone();
            figura.userData.initialScale = initialScale.clone();
            figura.userData.isLocked = false; // NUEVO: Propiedad para bloquear
            escena.add(figura);
            objetos.push(figura);
            actualizarLista();
            seleccionarFigura(figura);
            mostrarToast(`‚úîÔ∏è ${figura.name} agregado.`);
            registrarAccion({ type: 'add', objectId: figura.uuid, objectData: serializarObjeto(figura) });
        }

        // NUEVO: Funci√≥n para agregar Luz de Punto
        function agregarLuzPunto() {
            const pointLight = new THREE.PointLight(0xffffff, 1, 0); // Color, intensidad, distancia (0 = infinita)
            pointLight.position.set(Math.random() * 3 - 1.5, 2, Math.random() * 3 - 1.5);
            
            // A√±adir un helper visual para la luz
            const sphereSize = 0.2;
            const pointLightHelper = new THREE.Mesh(
                new THREE.SphereGeometry(sphereSize, 16, 16),
                new THREE.MeshBasicMaterial({ color: pointLight.color, transparent: true, opacity: 0.5 })
            );
            pointLightHelper.name = "Helper " + (contador.luzPunto + 1);
            pointLight.add(pointLightHelper); // El helper se mueve con la luz

            contador.luzPunto++;
            pointLight.name = "Luz de Punto " + contador.luzPunto;
            pointLight.userData.tipo = 'luzPunto';
            pointLight.userData.initialPosition = pointLight.position.clone();
            pointLight.userData.initialRotation = pointLight.rotation.clone(); // Las luces de punto no rotan visualmente, pero se guarda
            pointLight.userData.initialScale = new THREE.Vector3(1,1,1); // Las luces no escalan
            pointLight.userData.isLocked = false; // Propiedad para bloquear

            escena.add(pointLight);
            objetos.push(pointLight);
            actualizarLista();
            seleccionarFigura(pointLight);
            mostrarToast(`‚úîÔ∏è ${pointLight.name} agregada.`);
            registrarAccion({ type: 'add', objectId: pointLight.uuid, objectData: serializarObjeto(pointLight) });
        }


        function duplicarFigura() {
            if (!objetoSeleccionado) {
                mostrarToast("‚òùÔ∏è Selecciona una figura para duplicar.");
                return;
            }
            if (objetoSeleccionado.userData.isLocked) {
                mostrarToast("üîí Objeto bloqueado. Desbloqu√©alo para duplicar.");
                return;
            }

            const objData = serializarObjeto(objetoSeleccionado);
            delete objData.uuid;
            objData.keyframes = [];

            const nuevoObjeto = deserializarObjeto(objData);
            
            nuevoObjeto.position.x += 0.5;
            nuevoObjeto.position.y += 0.5;
            nuevoObjeto.position.z += 0.5;

            const tipo = nuevoObjeto.userData.tipo;
            contador[tipo]++;
            nuevoObjeto.name = tipo.charAt(0).toUpperCase() + tipo.slice(1) + " " + contador[tipo];
            nuevoObjeto.uuid = THREE.MathUtils.generateUUID();
            nuevoObjeto.userData.isLocked = false; // El duplicado no debe estar bloqueado por defecto

            escena.add(nuevoObjeto);
            objetos.push(nuevoObjeto);
            actualizarLista();
            seleccionarFigura(nuevoObjeto);
            mostrarToast(`‚úîÔ∏è ${nuevoObjeto.name} duplicado.`);
            registrarAccion({ type: 'add', objectId: nuevoObjeto.uuid, objectData: serializarObjeto(nuevoObjeto) });
        }

        // NUEVO: Agrupar objetos
        function agruparObjetos() {
            if (objetosSeleccionadosMultiples.length < 2) {
                mostrarToast("‚òùÔ∏è Selecciona al menos dos objetos para agrupar (Ctrl/Cmd + clic).");
                return;
            }

            const grupo = new THREE.Group();
            contador.grupo++;
            grupo.name = "Grupo " + contador.grupo;
            grupo.userData.tipo = 'grupo';
            grupo.userData.isLocked = false;

            // Calcular el centro del grupo para posicionarlo correctamente
            const bbox = new THREE.Box3();
            objetosSeleccionadosMultiples.forEach(obj => {
                bbox.expandByObject(obj);
            });
            const centro = new THREE.Vector3();
            bbox.getCenter(centro);
            grupo.position.copy(centro);

            // Mueve los objetos al grupo y ajusta sus posiciones relativas
            objetosSeleccionadosMultiples.forEach(obj => {
                // Aseg√∫rate de que el objeto no est√© bloqueado
                if (obj.userData.isLocked) {
                    mostrarToast(`üîí No se puede agrupar el objeto bloqueado: ${obj.name}.`);
                    return; // Salta este objeto si est√° bloqueado
                }
                grupo.attach(obj); // Mueve el objeto al grupo, manteniendo su posici√≥n global
                // Eliminar del array de objetos principales
                const index = objetos.indexOf(obj);
                if (index > -1) {
                    objetos.splice(index, 1);
                }
            });

            grupo.userData.initialPosition = grupo.position.clone();
            grupo.userData.initialRotation = grupo.rotation.clone();
            grupo.userData.initialScale = grupo.scale.clone();

            escena.add(grupo);
            objetos.push(grupo); // A√±ade el grupo a la lista principal de objetos
            
            // Limpiar selecci√≥n m√∫ltiple y seleccionar el grupo
            objetosSeleccionadosMultiples.length = 0;
            seleccionarFigura(grupo);
            actualizarLista();
            mostrarToast(`‚úîÔ∏è Grupo '${grupo.name}' creado con ${grupo.children.length} objetos.`);
            registrarAccion({ type: 'group', groupId: grupo.uuid, groupData: serializarObjeto(grupo), childUuids: grupo.children.map(c => c.uuid) });
        }

        // NUEVO: Desagrupar objetos
        function desagruparObjetos() {
            if (!objetoSeleccionado || objetoSeleccionado.userData.tipo !== 'grupo') {
                mostrarToast("‚òùÔ∏è Selecciona un grupo para desagrupar.");
                return;
            }
            if (objetoSeleccionado.userData.isLocked) {
                mostrarToast("üîí Grupo bloqueado. Desbloqu√©alo para desagrupar.");
                return;
            }

            const grupo = objetoSeleccionado;
            const childUuids = grupo.children.map(c => c.uuid); // Guardar UUIDs para deshacer/rehacer
            const oldGroupData = serializarObjeto(grupo); // Guardar estado del grupo

            // Mueve los hijos del grupo de vuelta a la escena principal
            // Es importante iterar de atr√°s hacia adelante al eliminar elementos de una colecci√≥n
            for (let i = grupo.children.length - 1; i >= 0; i--) {
                const child = grupo.children[i];
                escena.attach(child); // Mueve el hijo a la escena, manteniendo su posici√≥n global
                objetos.push(child); // A√±ade el hijo de nuevo a la lista principal de objetos
            }

            escena.remove(grupo); // Elimina el grupo vac√≠o de la escena
            const index = objetos.indexOf(grupo);
            if (index > -1) {
                objetos.splice(index, 1); // Elimina el grupo de la lista principal de objetos
            }

            objetoSeleccionado = null; // Deselecciona el grupo
            eliminarGizmos();
            ocultarColorPicker();
            actualizarLista();
            mostrarToast(`‚úîÔ∏è Grupo '${grupo.name}' desagrupado.`);
            registrarAccion({ type: 'ungroup', oldGroupData: oldGroupData, childUuids: childUuids });
        }

        // NUEVO: Resetear Transformaci√≥n
        function resetearTransformacion() {
            if (!objetoSeleccionado) {
                mostrarToast("‚òùÔ∏è Selecciona una figura para resetear su transformaci√≥n.");
                return;
            }
            if (objetoSeleccionado.userData.isLocked) {
                mostrarToast("üîí Objeto bloqueado. Desbloqu√©alo para resetear.");
                return;
            }

            const oldState = {
                position: objetoSeleccionado.position.clone(),
                rotation: objetoSeleccionado.rotation.clone(),
                scale: objetoSeleccionado.scale.clone()
            };

            objetoSeleccionado.position.set(0, 0, 0);
            objetoSeleccionado.rotation.set(0, 0, 0);
            objetoSeleccionado.scale.set(1, 1, 1);

            // Para luces de punto, la posici√≥n inicial puede ser diferente de (0,0,0)
            if (objetoSeleccionado.userData.tipo === 'luzPunto') {
                objetoSeleccionado.position.copy(objetoSeleccionado.userData.initialPosition || new THREE.Vector3(0,2,0));
            } else {
                objetoSeleccionado.position.copy(objetoSeleccionado.userData.initialPosition || new THREE.Vector3(0,0.6,0));
            }
            objetoSeleccionado.rotation.copy(objetoSeleccionado.userData.initialRotation || new THREE.Euler(0,0,0));
            objetoSeleccionado.scale.copy(objetoSeleccionado.userData.initialScale || new THREE.Vector3(1,1,1));


            crearGizmos(objetoSeleccionado);
            mostrarToast(`‚ôªÔ∏è Transformaci√≥n de ${objetoSeleccionado.name} reseteada.`);
            const newState = {
                position: objetoSeleccionado.position.clone(),
                rotation: objetoSeleccionado.rotation.clone(),
                scale: objetoSeleccionado.scale.clone()
            };
            registrarAccion({ type: 'transform', objectId: objetoSeleccionado.uuid, oldState: oldState, newState: newState });
        }


        function abrirImportadorModelo() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.glb, .gltf';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    cargarModeloGLB(file);
                }
            };
            input.click();
        }

        function cargarModeloGLB(file) {
            const reader = new FileReader();
            reader.onload = (event) => {
                const gltfLoader = new THREE.GLTFLoader();
                gltfLoader.parse(event.target.result, '', (gltf) => {
                    const model = gltf.scene;
                    model.position.set(Math.random() * 3 - 1.5, 0.6, Math.random() * 3 - 1.5);
                    model.scale.set(1, 1, 1);
                    contador.modelo++;
                    model.name = "Modelo " + contador.modelo;
                    model.userData.tipo = 'modelo';
                    model.userData.initialPosition = model.position.clone();
                    model.userData.initialRotation = model.rotation.clone();
                    model.userData.initialScale = model.scale.clone();
                    model.userData.gltfAnimations = gltf.animations;
                    model.userData.isLocked = false; // Propiedad para bloquear

                    model.traverse((child) => {
                        if (child.isMesh && child.material) {
                            if (child.material.color) {
                                model.userData.lastColor = child.material.color.getHex();
                            }
                        }
                    });
                    if (model.userData.lastColor === undefined) {
                         model.userData.lastColor = new THREE.MeshStandardMaterial().color.getHex();
                    }

                    escena.add(model);
                    objetos.push(model);
                    actualizarLista();
                    seleccionarFigura(model);
                    mostrarToast(`‚úîÔ∏è Modelo '${model.name}' importado.`);
                    registrarAccion({ type: 'add', objectId: model.uuid, objectData: serializarObjeto(model) });
                }, (xhr) => {
                    if (xhr.lengthComputable) {
                        const percentComplete = xhr.loaded / xhr.total * 100;
                        mostrarToast(`Cargando modelo: ${percentComplete.toFixed(0)}%`, 1000);
                    }
                }, (error) => {
                    console.error('Error al cargar GLB/glTF:', error);
                    mostrarToast("‚ùå Error al cargar el modelo 3D.");
                });
            };
            reader.readAsArrayBuffer(file);
        }

        function abrirImportadorTextura() {
            if (!objetoSeleccionado || objetoSeleccionado.userData.tipo === 'luzPunto') {
                mostrarToast("‚òùÔ∏è Selecciona una figura (no una luz) para aplicarle una textura.");
                return;
            }
            if (objetoSeleccionado.userData.isLocked) {
                mostrarToast("üîí Objeto bloqueado. Desbloqu√©alo para aplicar textura.");
                return;
            }

            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    aplicarTexturaAObjeto(objetoSeleccionado, file);
                }
            };
            input.click();
        }

        function aplicarTexturaAObjeto(obj, file) {
            const reader = new FileReader();
            reader.onload = (event) => {
                const textureLoader = new THREE.TextureLoader();
                textureLoader.load(event.target.result, (texture) => {
                    obj.userData.textureURL = event.target.result;

                    const oldMaterial = obj.material.clone();
                    let newMaterial;
                    if (obj.material instanceof THREE.MeshStandardMaterial) {
                        newMaterial = obj.material.clone();
                    } else {
                        newMaterial = new THREE.MeshStandardMaterial();
                        if (obj.material.color) newMaterial.color.copy(obj.material.color);
                    }
                    newMaterial.map = texture;
                    obj.material = newMaterial;
                    obj.material.needsUpdate = true;

                    mostrarToast(`‚úîÔ∏è Textura aplicada a ${obj.name}.`);
                    registrarAccion({ type: 'texture', objectId: obj.uuid, oldMaterialData: serializarMaterial(oldMaterial), newTextureURL: obj.userData.textureURL });
                }, undefined, (error) => {
                    console.error('Error al cargar la textura:', error);
                    mostrarToast("‚ùå Error al cargar la textura.");
                });
            };
            reader.readAsDataURL(file);
        }

        function serializarMaterial(material) {
            const data = {
                type: material.type,
                color: material.color ? material.color.getHex() : undefined,
                map: material.map ? material.map.image.src : undefined
            };
            return data;
        }

        function deserializarMaterial(materialData) {
            let material;
            if (materialData.type === 'MeshStandardMaterial') {
                material = new THREE.MeshStandardMaterial();
            } else if (materialData.type === 'MeshBasicMaterial') {
                material = new THREE.MeshBasicMaterial(); // Para los helpers de luz
            } else {
                material = new THREE.MeshStandardMaterial();
            }

            if (materialData.color !== undefined) {
                material.color.set(materialData.color);
            }
            if (materialData.map) {
                const textureLoader = new THREE.TextureLoader();
                material.map = textureLoader.load(materialData.map);
            }
            return material;
        }


        function eliminarFigura(obj) {
            if (obj.userData.isLocked) {
                mostrarToast("üîí Objeto bloqueado. Desbloqu√©alo para eliminar.");
                return;
            }
            mostrarDialogoConfirmacion('eliminar', obj);
        }

        function confirmarEliminar(obj) {
            const index = objetos.indexOf(obj);
            if (index > -1) {
                objetos.splice(index, 1);
                escena.remove(obj);
                if (objetoSeleccionado && objetoSeleccionado.uuid === obj.uuid) {
                    objetoSeleccionado = null;
                    eliminarGizmos();
                    ocultarColorPicker();
                }
                // Limpiar bboxHelper si existe
                if (obj.userData.bboxHelper) {
                    escena.remove(obj.userData.bboxHelper);
                    obj.userData.bboxHelper.dispose();
                    obj.userData.bboxHelper = null;
                }
                actualizarLista();
                mostrarToast(`üóëÔ∏è ${obj.name} eliminado.`);
                registrarAccion({ type: 'delete', objectData: serializarObjeto(obj) });
            }
        }

        // NUEVO: Funci√≥n para bloquear/desbloquear objeto
        function toggleBloquearObjeto(obj) {
            obj.userData.isLocked = !obj.userData.isLocked;
            actualizarLista(); // Para que el icono y la clase se actualicen
            seleccionarFigura(obj); // Para actualizar el estado de los gizmos
            mostrarToast(`${obj.name} ${obj.userData.isLocked ? 'bloqueado üîí' : 'desbloqueado üîì'}.`);
            registrarAccion({ type: 'lock', objectId: obj.uuid, newState: obj.userData.isLocked });
        }


        function actualizarLista() {
            listaContenido.innerHTML = "";
            if (objetos.length === 0) {
                listaContenido.innerHTML = "<p style='padding: 10px; text-align: center; color: #aaa; font-size:12px;'>No hay figuras en la escena.</p>";
                return;
            }
            objetos.forEach(obj => {
                const item = document.createElement("div");
                item.className = `itemLista ${objetoSeleccionado && objetoSeleccionado.uuid === obj.uuid ? 'seleccionado' : ''} ${obj.userData.isLocked ? 'bloqueado' : ''}`;
                // Guardar el elemento HTML en userData para selecci√≥n m√∫ltiple
                obj.element = item;
                item.setAttribute('data-uuid', obj.uuid); // A√±adir data-uuid para f√°cil selecci√≥n

                const nameSpan = document.createElement("span");
                nameSpan.className = "nombre-item";
                nameSpan.textContent = obj.name;
                nameSpan.onclick = (e) => {
                    e.stopPropagation();
                    seleccionarFiguraDesdeLista(obj, e.ctrlKey || e.metaKey); // A√±adir soporte para Ctrl/Cmd
                };

                const renameInput = document.createElement("input");
                renameInput.type = "text";
                renameInput.value = obj.name;
                renameInput.style.display = "none";
                renameInput.addEventListener('click', (e) => e.stopPropagation());
                renameInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        const newName = renameInput.value.trim();
                        if (newName && newName !== obj.name) {
                            const oldName = obj.name;
                            obj.name = newName;
                            nameSpan.textContent = newName;
                            mostrarToast(`‚úîÔ∏è ${oldName} renombrado a ${newName}.`);
                            registrarAccion({ type: 'rename', objectId: obj.uuid, oldName: oldName, newName: newName });
                        }
                        renameInput.style.display = "none";
                        nameSpan.style.display = "block";
                    } else if (e.key === 'Escape') {
                        renameInput.value = obj.name;
                        renameInput.style.display = "none";
                        nameSpan.style.display = "block";
                    }
                });
                renameInput.addEventListener('blur', () => {
                    if (renameInput.style.display === "block") {
                        const newName = renameInput.value.trim();
                        if (newName && newName !== obj.name) {
                            const oldName = obj.name;
                            obj.name = newName;
                            nameSpan.textContent = newName;
                            mostrarToast(`‚úîÔ∏è ${oldName} renombrado a ${newName}.`);
                            registrarAccion({ type: 'rename', objectId: obj.uuid, oldName: oldName, newName: newName });
                        }
                        renameInput.style.display = "none";
                        nameSpan.style.display = "block";
                    }
                });

                const buttonsDiv = document.createElement("div");
                buttonsDiv.className = "botones-item";

                // NUEVO: Bot√≥n de Bloquear/Desbloquear
                const lockButton = document.createElement("button");
                lockButton.className = `boton-bloquear-item ${obj.userData.isLocked ? 'activo' : ''}`;
                lockButton.textContent = obj.userData.isLocked ? 'üîì' : 'üîí';
                lockButton.title = obj.userData.isLocked ? 'Desbloquear' : 'Bloquear';
                lockButton.onclick = (e) => {
                    e.stopPropagation();
                    toggleBloquearObjeto(obj);
                };

                const renameButton = document.createElement("button");
                renameButton.className = "boton-renombrar-item";
                renameButton.textContent = "‚úé";
                renameButton.title = "Renombrar";
                renameButton.onclick = (e) => {
                    e.stopPropagation();
                    if (obj.userData.isLocked) {
                        mostrarToast("üîí Objeto bloqueado. Desbloqu√©alo para renombrar.");
                        return;
                    }
                    nameSpan.style.display = "none";
                    renameInput.style.display = "block";
                    renameInput.focus();
                    renameInput.select();
                };

                const deleteButton = document.createElement("button");
                deleteButton.className = "boton-eliminar-item";
                deleteButton.textContent = "X";
                deleteButton.title = "Eliminar";
                deleteButton.onclick = (e) => {
                    e.stopPropagation();
                    eliminarFigura(obj);
                };
                
                buttonsDiv.appendChild(lockButton); // A√±adir bot√≥n de bloqueo
                buttonsDiv.appendChild(renameButton);
                buttonsDiv.appendChild(deleteButton);
                
                item.appendChild(nameSpan);
                item.appendChild(renameInput);
                item.appendChild(buttonsDiv);
                listaContenido.appendChild(item);
            });
        }

        // Modificado: seleccionarFiguraDesdeLista para selecci√≥n m√∫ltiple
        function seleccionarFiguraDesdeLista(obj, esMultiple = false) {
            if (obj.userData.isLocked && !esMultiple) { // Si est√° bloqueado y no es selecci√≥n m√∫ltiple, no lo selecciones
                mostrarToast(`üîí ${obj.name} est√° bloqueado.`);
                return;
            }

            if (esMultiple) {
                const index = objetosSeleccionadosMultiples.indexOf(obj);
                if (index > -1) {
                    objetosSeleccionadosMultiples.splice(index, 1); // Deseleccionar
                    obj.element.classList.remove('seleccionado'); // Eliminar clase visual
                } else {
                    if (obj.userData.isLocked) { // No permitir seleccionar objetos bloqueados en selecci√≥n m√∫ltiple
                        mostrarToast(`üîí ${obj.name} est√° bloqueado y no se puede seleccionar para agrupar.`);
                        return;
                    }
                    objetosSeleccionadosMultiples.push(obj); // Seleccionar
                    obj.element.classList.add('seleccionado'); // A√±adir clase visual
                }
                // Deseleccionar el objeto √∫nico si hay selecci√≥n m√∫ltiple activa
                if (objetoSeleccionado && !objetosSeleccionadosMultiples.includes(objetoSeleccionado)) {
                    objetoSeleccionado = null;
                    eliminarGizmos();
                    ocultarColorPicker();
                }
                mostrarToast(`Seleccionados: ${objetosSeleccionadosMultiples.length} objetos.`);
                actualizarLista(); // Para refrescar los estilos
            } else {
                // Limpiar selecci√≥n m√∫ltiple si se selecciona un solo objeto sin Ctrl/Cmd
                objetosSeleccionadosMultiples.forEach(o => {
                    const listItem = document.querySelector(`.itemLista.seleccionado[data-uuid="${o.uuid}"]`);
                    if (listItem) listItem.classList.remove('seleccionado');
                });
                objetosSeleccionadosMultiples.length = 0;
                seleccionarFigura(obj);
            }
        }


        function seleccionarFigura(obj) {
            if (obj && obj.userData.isLocked) {
                mostrarToast(`üîí ${obj.name} est√° bloqueado.`);
                return;
            }
            if (objetoSeleccionado === obj) return;
            if (objetoSeleccionado) {
                const oldItem = document.querySelector(`.itemLista.seleccionado`);
                if (oldItem) oldItem.classList.remove('seleccionado');
                if (objetoSeleccionado.isSkinnedMesh) {
                    escena.children.forEach(child => {
                        if (child instanceof THREE.SkeletonHelper) {
                            escena.remove(child);
                        }
                    });
                    objetoSeleccionado.skeleton.bones.forEach(bone => {
                        const helpers = bone.children.filter(c => c instanceof THREE.AxesHelper);
                        helpers.forEach(h => bone.remove(h));
                    });
                }
            }

            objetoSeleccionado = obj;
            if (!riggingModeActivo) {
                crearGizmos(objetoSeleccionado);
            } else {
                eliminarGizmos();
                if (objetoSeleccionado.isSkinnedMesh) {
                     escena.add(new THREE.SkeletonHelper(objetoSeleccionado.skeleton));
                     objetoSeleccionado.skeleton.bones.forEach(bone => {
                        const boneHelper = new THREE.AxesHelper(0.1);
                        bone.add(boneHelper);
                    });
                }
            }
            // Actualizar panel de color y luz de punto
            if (objetoSeleccionado && objetoSeleccionado.userData.tipo === 'luzPunto') {
                ocultarColorPicker(); // Ocultar el color picker de material
                pointLightIntensitySlider.value = objetoSeleccionado.intensity;
                pointLightIntensityLabel.textContent = objetoSeleccionado.intensity.toFixed(1);
                pointLightDistanceSlider.value = objetoSeleccionado.distance;
                pointLightDistanceLabel.textContent = objetoSeleccionado.distance.toFixed(1) + (objetoSeleccionado.distance === 0 ? " (infinita)" : "");
                pointLightColorPicker.value = "#" + objetoSeleccionado.color.getHexString();
            } else {
                mostrarColorPicker(objetoSeleccionado); // Mostrar color picker de material
            }
            
            mostrarToast(`‚ú® ${obj.name} seleccionado.`);
            actualizarLista();
        }

        function centrarFigura() {
            if (objetoSeleccionado) {
                if (objetoSeleccionado.userData.isLocked) {
                    mostrarToast("üîí Objeto bloqueado. Desbloqu√©alo para centrar.");
                    return;
                }
                const oldPos = objetoSeleccionado.position.clone();
                objetoSeleccionado.position.set(0, objetoSeleccionado.position.y, 0);
                mostrarToast(`üéØ ${objetoSeleccionado.name} centrado.`);
                registrarAccion({ type: 'transform', objectId: objetoSeleccionado.uuid, oldState: { position: oldPos.clone(), rotation: objetoSeleccionado.rotation.clone(), scale: objetoSeleccionado.scale.clone() }, newState: { position: objetoSeleccionado.position.clone(), rotation: objetoSeleccionado.rotation.clone(), scale: objetoSeleccionado.scale.clone() } });
            } else {
                mostrarToast("‚òùÔ∏è Selecciona una figura primero.");
            }
        }

        // --- Gizmos de Transformaci√≥n ---
        // REDUCIDO EL TAMA√ëO DE LOS GIZMOS AQU√ç
        const ESCALA_GIZMO = 0.8; // Factor de escala para todos los gizmos

        function crearGizmosTraslacion(obj) {
            const colores = [0xff0000, 0x00ff00, 0x0000ff];
            const ejes = ['x', 'y', 'z'];
            const rotaciones = [
                new THREE.Vector3(0, 0, -Math.PI / 2),
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(Math.PI / 2, 0, 0)
            ];

            for (let i = 0; i < 3; i++) {
                const grupo = new THREE.Group();
                const barra = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.02 * ESCALA_GIZMO, 0.02 * ESCALA_GIZMO, 1 * ESCALA_GIZMO, 8),
                    new THREE.MeshBasicMaterial({ color: colores[i], transparent: true, opacity: 0.8 }));
                barra.position.y = 0.5 * ESCALA_GIZMO;
                const punta = new THREE.Mesh(
                    new THREE.ConeGeometry(0.06 * ESCALA_GIZMO, 0.2 * ESCALA_GIZMO, 8),
                    new THREE.MeshBasicMaterial({ color: colores[i], transparent: true, opacity: 0.8 }));
                punta.position.y = 1.1 * ESCALA_GIZMO;
                grupo.add(barra);
                grupo.add(punta);

                grupo.rotation.set(rotaciones[i].x, rotaciones[i].y, rotaciones[i].z);
                grupo.position.copy(obj.position);
                grupo.userData.eje = ejes[i];
                grupo.userData.tipoGizmo = 'traslacion';
                escena.add(grupo);
                gizmos.push(grupo);
            }
        }

        function crearGizmosRotacion(obj) {
            const colores = [0xff0000, 0x00ff00, 0x0000ff];
            const ejes = ['x', 'y', 'z'];
            const rotaciones = [
                new THREE.Vector3(0, Math.PI / 2, 0),
                new THREE.Vector3(Math.PI / 2, 0, 0),
                new THREE.Vector3(0, 0, 0)
            ];
            const bbox = new THREE.Box3().setFromObject(obj);
            const size = new THREE.Vector3();
            bbox.getSize(size);
            const maxDim = Math.max(size.x, size.y, size.z);
            const radioAnillo = maxDim * 0.7 * ESCALA_GIZMO; // Ajuste de escala para el radio

            for (let i = 0; i < 3; i++) {
                const anillo = new THREE.Mesh(
                    new THREE.TorusGeometry(radioAnillo, 0.02 * ESCALA_GIZMO, 16, 100), // Grosor del anillo tambi√©n escalado
                    new THREE.MeshBasicMaterial({ color: colores[i], transparent: true, opacity: 0.8, side: THREE.DoubleSide })
                );
                anillo.position.copy(obj.position);
                anillo.rotation.set(rotaciones[i].x, rotaciones[i].y, rotaciones[i].z);
                anillo.userData.eje = ejes[i];
                anillo.userData.tipoGizmo = 'rotacion';
                escena.add(anillo);
                gizmos.push(anillo);
            }
        }

        function crearGizmosEscala(obj) {
            gizmos = gizmos.filter(g => g.userData.tipoGizmo !== 'escala');

            const size = new THREE.Vector3();
            new THREE.Box3().setFromObject(obj).getSize(size);

            const halfSize = size.multiplyScalar(0.5);
            const posicionesRelativas = [
                new THREE.Vector3(halfSize.x, halfSize.y, halfSize.z),
                new THREE.Vector3(-halfSize.x, halfSize.y, halfSize.z),
                new THREE.Vector3(halfSize.x, -halfSize.y, halfSize.z),
                new THREE.Vector3(halfSize.x, halfSize.y, -halfSize.z),
                new THREE.Vector3(-halfSize.x, -halfSize.y, halfSize.z),
                new THREE.Vector3(-halfSize.x, halfSize.y, -halfSize.z),
                new THREE.Vector3(halfSize.x, -halfSize.y, -halfSize.z),
                new THREE.Vector3(-halfSize.x, -halfSize.y, -halfSize.z)
            ];

            const gizmoSize = 0.15 * ESCALA_GIZMO; // Ajuste de escala para el tama√±o de los cubos
            for (const posRel of posicionesRelativas) {
                const cuboGizmo = new THREE.Mesh(
                    new THREE.BoxGeometry(gizmoSize, gizmoSize, gizmoSize),
                    new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.8 })
                );
                obj.add(cuboGizmo);
                cuboGizmo.position.copy(posRel);

                cuboGizmo.userData.tipoGizmo = 'escala';
                cuboGizmo.userData.direccionLocalEscala = posRel.clone().normalize();
                gizmos.push(cuboGizmo);
            }
        }


        function crearGizmos(obj) {
            eliminarGizmos();
            if (!obj) return;
            if (riggingModeActivo) return;
            if (obj.userData.isLocked) return; // No crear gizmos si el objeto est√° bloqueado

            switch (modoTransformacion) {
                case 'trasladar':
                    crearGizmosTraslacion(obj);
                    break;
                case 'rotar':
                    crearGizmosRotacion(obj);
                    break;
                case 'escalar':
                    crearGizmosEscala(obj);
                    break;
            }
        }

        function eliminarGizmos() {
            gizmos.forEach(g => {
                if (g.parent) {
                    g.parent.remove(g);
                } else {
                    escena.remove(g);
                }
            });
            gizmos = [];
        }

        // --- Manejo de Eventos T√°ctiles ---
        let tocando = false;
        let objetoArrastrando = null;
        let ultimoEstadoObjeto = null;

        render.domElement.addEventListener("touchstart", e => {
            if (riggingModeActivo) {
                controls.enabled = false;
                return;
            }
            controls.enabled = true;

            if (e.touches.length === 1) {
                previousTouchPos.set(e.touches[0].clientX, e.touches[0].clientY);
                tocando = true;
                objetoArrastrando = null;

                const rect = render.domElement.getBoundingClientRect();
                puntero.x = ((e.touches[0].clientX - rect.left) / rect.width) * 2 - 1;
                puntero.y = -((e.touches[0].clientY - rect.top) / rect.height) * 2 + 1;
                raycaster.setFromCamera(puntero, camara);

                const interGizmo = raycaster.intersectObjects(gizmos, true);

                if (interGizmo.length > 0 && objetoSeleccionado) {
                    let hitGizmo = interGizmo[0].object;
                    while (hitGizmo && !hitGizmo.userData.tipoGizmo) {
                        hitGizmo = hitGizmo.parent;
                    }

                    if (hitGizmo && (hitGizmo.userData.tipoGizmo === 'traslacion' || hitGizmo.userData.tipoGizmo === 'rotacion' || hitGizmo.userData.tipoGizmo === 'escala')) {
                        if (objetoSeleccionado.userData.isLocked) { // Comprobar bloqueo al arrastrar gizmo
                            mostrarToast("üîí Objeto bloqueado. Desbloqu√©alo para mover.");
                            return;
                        }
                        objetoArrastrando = hitGizmo;

                        if (objetoArrastrando.userData.tipoGizmo === 'traslacion') {
                            puntoInterseccionInicial3D.copy(interGizmo[0].point);
                        }

                        ultimoEstadoObjeto = {
                            position: objetoSeleccionado.position.clone(),
                            rotation: objetoSeleccionado.rotation.clone(),
                            scale: objetoSeleccionado.scale.clone()
                        };
                        controls.enabled = false;
                        e.preventDefault();
                        return;
                    }
                }

                const interObj = raycaster.intersectObjects(objetos);
                if (interObj.length > 0) {
                    seleccionarFigura(interObj[0].object);
                    controls.enabled = false;
                    e.preventDefault();
                    return;
                }

                if (objetoSeleccionado) {
                    objetoSeleccionado = null;
                    eliminarGizmos();
                    ocultarColorPicker();
                    actualizarLista();
                    mostrarToast("ü§∑‚Äç‚ôÇÔ∏è Nada seleccionado.");
                }

            } else if (e.touches.length === 2) {
                controls.enabled = true;
                objetoArrastrando = null;
            }
        }, { passive: false });

        render.domElement.addEventListener("touchmove", e => {
            if (riggingModeActivo) {
                return;
            }
            if (controls.enabled) {
                return;
            }
            if (!tocando || !objetoSeleccionado || e.touches.length > 1) {
                return;
            }
            if (objetoSeleccionado.userData.isLocked) { // Comprobar bloqueo al mover
                return;
            }

            e.preventDefault();

            const rect = render.domElement.getBoundingClientRect();
            const currentTouchX = e.touches[0].clientX;
            const currentTouchY = e.touches[0].clientY;

            let deltaPixelX = 0;
            let deltaPixelY = 0;
            if (objetoArrastrando.userData.tipoGizmo === 'rotacion' || objetoArrastrando.userData.tipoGizmo === 'escala') {
                deltaPixelX = currentTouchX - previousTouchPos.x;
                deltaPixelY = currentTouchY - previousTouchPos.y;
            }

            const sensitivity = velocidadMovimiento;

            if (objetoArrastrando.userData.tipoGizmo === 'traslacion') {
                const eje = objetoArrastrando.userData.eje;
                
                puntero.x = ((currentTouchX - rect.left) / rect.width) * 2 - 1;
                puntero.y = -((e.touches[0].clientY - rect.top) / rect.height) * 2 + 1;
                raycaster.setFromCamera(puntero, camara);

                const cameraDirection = new THREE.Vector3();
                camara.getWorldDirection(cameraDirection);
                const plane = new THREE.Plane();
                plane.setFromNormalAndCoplanarPoint(cameraDirection, puntoInterseccionInicial3D);

                const nuevaInterseccion3D = new THREE.Vector3();
                if (!raycaster.ray.intersectPlane(plane, nuevaInterseccion3D)) {
                    return;
                }

                const deltaMovimiento3D = new THREE.Vector3().subVectors(nuevaInterseccion3D, puntoInterseccionInicial3D);

                const axisWorld = new THREE.Vector3();
                if (eje === 'x') axisWorld.set(1, 0, 0);
                else if (eje === 'y') axisWorld.set(0, 1, 0);
                else if (eje === 'z') axisWorld.set(0, 0, 1);
                axisWorld.normalize();

                const moveAmount = deltaMovimiento3D.dot(axisWorld);
                objetoSeleccionado.position.add(axisWorld.multiplyScalar(moveAmount));
                puntoInterseccionInicial3D.copy(nuevaInterseccion3D);

                gizmos.forEach(g => {
                    if (g.userData.tipoGizmo === 'traslacion') {
                        g.position.copy(objetoSeleccionado.position);
                    }
                });

            } else if (objetoArrastrando.userData.tipoGizmo === 'rotacion') {
                const eje = objetoArrastrando.userData.eje;
                const rotationSpeed = sensitivity * 0.005;

                let deltaRotation = 0;
                let axis = new THREE.Vector3();

                if (eje === 'x') {
                    axis.set(1, 0, 0);
                    deltaRotation = -deltaPixelY * rotationSpeed;
                } else if (eje === 'y') {
                    axis.set(0, 1, 0);
                    deltaRotation = deltaPixelX * rotationSpeed;
                } else if (eje === 'z') {
                    axis.set(0, 0, 1);
                    deltaRotation = (deltaPixelX - deltaPixelY) * rotationSpeed;
                }
                objetoSeleccionado.rotateOnWorldAxis(axis, deltaRotation);
                gizmos.filter(g => g.userData.tipoGizmo === 'rotacion').forEach(g => g.position.copy(objetoSeleccionado.position));

            } else if (objetoArrastrando.userData.tipoGizmo === 'escala') {
                const scaleSpeed = sensitivity * 0.01;
                const deltaScale = (deltaPixelX - deltaPixelY) * scaleSpeed;

                const currentScale = objetoSeleccionado.scale.x;
                let newScale = currentScale + deltaScale;
                newScale = Math.max(0.01, newScale);

                objetoSeleccionado.scale.set(newScale, newScale, newScale);
            }
            previousTouchPos.set(currentTouchX, currentTouchY);

        }, { passive: false });

        render.domElement.addEventListener("touchend", () => {
            tocando = false;
            if (riggingModeActivo) {
                return;
            }

            if (objetoArrastrando && objetoSeleccionado) {
                const newState = {
                    position: objetoSeleccionado.position.clone(),
                    rotation: objetoSeleccionado.rotation.clone(),
                    scale: objetoSeleccionado.scale.clone()
                };
                if (ultimoEstadoObjeto && (
                    !ultimoEstadoObjeto.position.equals(newState.position) ||
                    !ultimoEstadoObjeto.rotation.equals(newState.rotation) ||
                    !ultimoEstadoObjeto.scale.equals(newState.scale)
                )) {
                    registrarAccion({ type: 'transform', objectId: objetoSeleccionado.uuid, oldState: ultimoEstadoObjeto, newState: newState });
                }
                ultimoEstadoObjeto = null;
                objetoArrastrando = null;
            }
            controls.enabled = true;
        });

        // --- Historial de Acciones (Undo/Redo) ---

        const historial = [];
        let indiceHistorial = -1;
        const MAX_HISTORIAL = 50;

        function registrarAccion(accion) {
            if (indiceHistorial < historial.length - 1) {
                historial.splice(indiceHistorial + 1);
            }
            historial.push(accion);
            if (historial.length > MAX_HISTORIAL) {
                historial.shift();
            }
            indiceHistorial = historial.length - 1;
            actualizarBotonesUndoRedo();
        }

        function deshacerAccion() {
            if (indiceHistorial < 0) {
                mostrarToast("ü§∑‚Äç‚ôÄÔ∏è No hay acciones para deshacer.");
                return;
            }

            const accion = historial[indiceHistorial];
            const obj = escena.getObjectByProperty('uuid', accion.objectId);

            switch (accion.type) {
                case 'add':
                    if (obj) {
                        escena.remove(obj);
                        objetos.splice(objetos.indexOf(obj), 1);
                        if (objetoSeleccionado === obj) {
                            objetoSeleccionado = null;
                            eliminarGizmos();
                            ocultarColorPicker();
                        }
                        // Limpiar bboxHelper si existe
                        if (obj.userData.bboxHelper) {
                            escena.remove(obj.userData.bboxHelper);
                            obj.userData.bboxHelper.dispose();
                            obj.userData.bboxHelper = null;
                        }
                        actualizarLista();
                        mostrarToast(`‚Ü© Deshecho: A√±adir ${obj.name}`);
                    }
                    break;
                case 'delete':
                    if (accion.objectData) {
                        const newObj = deserializarObjeto(accion.objectData);
                        escena.add(newObj);
                        objetos.push(newObj);
                        actualizarLista();
                        seleccionarFigura(newObj);
                        mostrarToast(`‚Ü© Deshecho: Eliminar ${newObj.name}`);
                    }
                    break;
                case 'transform':
                    if (obj && accion.oldState) {
                        obj.position.copy(accion.oldState.position);
                        obj.rotation.copy(accion.oldState.rotation);
                        obj.scale.copy(accion.oldState.scale);
                        if (objetoSeleccionado === obj) {
                            crearGizmos(obj);
                        }
                        mostrarToast(`‚Ü© Deshecho: Mover ${obj.name}`);
                    }
                    break;
                case 'color':
                    if (obj && accion.oldColor !== undefined) {
                        obj.material.color.set(accion.oldColor);
                        if (objetoSeleccionado === obj) {
                            colorPicker.value = "#" + obj.material.color.getHexString();
                        }
                        mostrarToast(`‚Ü© Deshecho: Color ${obj.name}`);
                    }
                    break;
                case 'texture':
                    if (obj && accion.oldMaterialData) {
                        obj.material = deserializarMaterial(accion.oldMaterialData);
                        obj.material.needsUpdate = true;
                        obj.userData.textureURL = accion.oldMaterialData.map;
                        mostrarToast(`‚Ü© Deshecho: Textura para ${obj.name}`);
                    }
                    break;
                case 'rename':
                    if (obj && accion.oldName !== undefined) {
                        obj.name = accion.oldName;
                        actualizarLista();
                        mostrarToast(`‚Ü© Deshecho: Renombrar a ${obj.name}`);
                    }
                    break;
                case 'ambientIntensity':
                    if (accion.oldIntensity !== undefined) {
                        ambientLight.intensity = accion.oldIntensity;
                        ambientLightIntensitySlider.value = accion.oldIntensity;
                        ambientLightIntensityLabel.textContent = accion.oldIntensity.toFixed(2);
                        mostrarToast(`‚Ü© Deshecho: Intensidad Luz Ambiente`);
                    }
                    break;
                case 'ambientColor':
                    if (accion.oldColor !== undefined) {
                        ambientLight.color.set(accion.oldColor);
                        ambientLightColorPicker.value = "#" + new THREE.Color(accion.oldColor).getHexString();
                        mostrarToast(`‚Ü© Deshecho: Color Luz Ambiente`);
                    }
                    break;
                case 'skybox':
                    toggleSkybox(!accion.newState);
                    skyboxCheckbox.checked = !accion.newState;
                    mostrarToast(`‚Ü© Deshecho: Skybox ${!accion.newState ? 'Activado' : 'Desactivado'}`);
                    break;
                case 'lock': // NUEVO: Deshacer bloqueo
                    if (obj) {
                        obj.userData.isLocked = !accion.newState;
                        actualizarLista();
                        if (objetoSeleccionado === obj) { // Si estaba seleccionado y se desbloquea, crear gizmos
                            crearGizmos(obj);
                        } else if (obj.userData.isLocked) { // Si se bloquea, eliminar gizmos si los ten√≠a
                             eliminarGizmos();
                        }
                        mostrarToast(`‚Ü© Deshecho: ${obj.name} ${obj.userData.isLocked ? 'bloqueado' : 'desbloqueado'}`);
                    }
                    break;
                case 'group': // NUEVO: Deshacer agrupar
                    if (obj) { // obj es el grupo
                        // Quitar el grupo de la escena y objetos
                        escena.remove(obj);
                        objetos.splice(objetos.indexOf(obj), 1);

                        // Re-a√±adir los hijos a la escena y objetos
                        accion.childUuids.forEach(childUuid => {
                            const childObj = escena.getObjectByProperty('uuid', childUuid);
                            if (childObj) {
                                escena.attach(childObj);
                                objetos.push(childObj);
                            }
                        });
                        objetoSeleccionado = null;
                        eliminarGizmos();
                        ocultarColorPicker();
                        actualizarLista();
                        mostrarToast(`‚Ü© Deshecho: Agrupar ${obj.name}`);
                    }
                    break;
                case 'ungroup': // NUEVO: Deshacer desagrupar
                    if (obj) { // obj es el objeto original (el grupo se elimina al desagrupar)
                        // No hay un objeto con el UUID del grupo original despu√©s de desagrupar,
                        // por lo que deserializamos el grupo completo y lo re-ensamblamos
                        const oldGroup = deserializarObjeto(accion.oldGroupData);
                        escena.add(oldGroup);
                        objetos.push(oldGroup);
                        
                        // Mover los hijos de vuelta al grupo
                        accion.childUuids.forEach(childUuid => {
                            const childObj = escena.getObjectByProperty('uuid', childUuid); // Esto a√∫n apunta a los objetos en la escena global
                            if (childObj) {
                                oldGroup.attach(childObj);
                                // Asegurarse de que el hijo no est√© duplicado en la lista principal de objetos
                                const idx = objetos.indexOf(childObj);
                                if (idx > -1) objetos.splice(idx, 1);
                            }
                        });
                        seleccionarFigura(oldGroup);
                        actualizarLista();
                        mostrarToast(`‚Ü© Deshecho: Desagrupar ${oldGroup.name}`);
                    }
                    break;
                case 'lightIntensity': // Deshacer intensidad de luz de punto
                    if (obj && obj.userData.tipo === 'luzPunto' && accion.oldIntensity !== undefined) {
                        obj.intensity = accion.oldIntensity;
                        if (objetoSeleccionado === obj) {
                            pointLightIntensitySlider.value = obj.intensity;
                            pointLightIntensityLabel.textContent = obj.intensity.toFixed(1);
                        }
                        mostrarToast(`‚Ü© Deshecho: Intensidad de luz ${obj.name}`);
                    }
                    break;
                case 'lightDistance': // Deshacer distancia de luz de punto
                    if (obj && obj.userData.tipo === 'luzPunto' && accion.oldDistance !== undefined) {
                        obj.distance = accion.oldDistance;
                        if (objetoSeleccionado === obj) {
                            pointLightDistanceSlider.value = obj.distance;
                            pointLightDistanceLabel.textContent = obj.distance.toFixed(1) + (obj.distance === 0 ? " (infinita)" : "");
                        }
                        mostrarToast(`‚Ü© Deshecho: Distancia de luz ${obj.name}`);
                    }
                    break;
                case 'lightColor': // Deshacer color de luz de punto
                    if (obj && obj.userData.tipo === 'luzPunto' && accion.oldColor !== undefined) {
                        obj.color.set(accion.oldColor);
                        if (objetoSeleccionado === obj) {
                            pointLightColorPicker.value = "#" + obj.color.getHexString();
                            // Actualizar color del helper visual si existe
                            const helper = obj.children.find(c => c.name.startsWith(`Helper `));
                            if (helper && helper.material) {
                                helper.material.color.set(obj.color);
                            }
                        }
                        mostrarToast(`‚Ü© Deshecho: Color de luz ${obj.name}`);
                    }
                    break;
            }
            indiceHistorial--;
            actualizarBotonesUndoRedo();
        }

        function rehacerAccion() {
            if (indiceHistorial >= historial.length - 1) {
                mostrarToast("ü§∑‚Äç‚ôÄÔ∏è No hay acciones para rehacer.");
                return;
            }
            indiceHistorial++;
            const accion = historial[indiceHistorial];
            const obj = escena.getObjectByProperty('uuid', accion.objectId);

            switch (accion.type) {
                case 'add':
                    if (accion.objectData) {
                        const newObj = deserializarObjeto(accion.objectData);
                        escena.add(newObj);
                        objetos.push(newObj);
                        actualizarLista();
                        seleccionarFigura(newObj);
                        mostrarToast(`‚Ü™ Rehaciendo: A√±adir ${newObj.name}`);
                    }
                    break;
                case 'delete':
                    if (obj) {
                        escena.remove(obj);
                        objetos.splice(objetos.indexOf(obj), 1);
                        if (objetoSeleccionado === obj) {
                            objetoSeleccionado = null;
                            eliminarGizmos();
                            ocultarColorPicker();
                        }
                        // Limpiar bboxHelper si existe
                        if (obj.userData.bboxHelper) {
                            escena.remove(obj.userData.bboxHelper);
                            obj.userData.bboxHelper.dispose();
                            obj.userData.bboxHelper = null;
                        }
                        actualizarLista();
                        mostrarToast(`‚Ü™ Rehaciendo: Eliminar ${obj.name}`);
                    }
                    break;
                case 'transform':
                    if (obj && accion.newState) {
                        obj.position.copy(accion.newState.position);
                        obj.rotation.copy(accion.newState.rotation);
                        obj.scale.copy(accion.newState.scale);
                        if (objetoSeleccionado === obj) {
                            crearGizmos(obj);
                        }
                        mostrarToast(`‚Ü™ Rehaciendo: Mover ${obj.name}`);
                    }
                    break;
                case 'color':
                    if (obj && accion.newColor !== undefined) {
                        obj.material.color.set(accion.newColor);
                        if (objetoSeleccionado === obj) {
                            colorPicker.value = "#" + obj.material.color.getHexString();
                        }
                        mostrarToast(`‚Ü™ Rehaciendo: Color ${obj.name}`);
                    }
                    break;
                case 'texture':
                    if (obj && accion.newTextureURL) {
                        const textureLoader = new THREE.TextureLoader();
                        textureLoader.load(accion.newTextureURL, (texture) => {
                            let newMaterial;
                            if (obj.material instanceof THREE.MeshStandardMaterial) {
                                newMaterial = obj.material.clone();
                            } else {
                                newMaterial = new THREE.MeshStandardMaterial();
                                if (obj.material.color) newMaterial.color.copy(obj.material.color);
                            }
                            newMaterial.map = texture;
                            obj.material = newMaterial;
                            obj.material.needsUpdate = true;
                            obj.userData.textureURL = accion.newTextureURL;
                            mostrarToast(`‚Ü™ Rehaciendo: Textura para ${obj.name}`);
                        });
                    }
                    break;
                case 'rename':
                    if (obj && accion.newName !== undefined) {
                        obj.name = accion.newName;
                        actualizarLista();
                        mostrarToast(`‚Ü™ Rehaciendo: Renombrar a ${obj.name}`);
                    }
                    break;
                case 'ambientIntensity':
                    if (accion.newIntensity !== undefined) {
                        ambientLight.intensity = accion.newIntensity;
                        ambientLightIntensitySlider.value = accion.newIntensity;
                        ambientLightIntensityLabel.textContent = accion.newIntensity.toFixed(2);
                        mostrarToast(`‚Ü™ Rehaciendo: Intensidad Luz Ambiente`);
                    }
                    break;
                case 'ambientColor':
                    if (accion.newColor !== undefined) {
                        ambientLight.color.set(accion.newColor);
                        ambientLightColorPicker.value = "#" + new THREE.Color(accion.newColor).getHexString();
                        mostrarToast(`‚Ü™ Rehaciendo: Color Luz Ambiente`);
                    }
                    break;
                case 'skybox':
                    toggleSkybox(accion.newState);
                    skyboxCheckbox.checked = accion.newState;
                    mostrarToast(`‚Ü™ Rehaciendo: Skybox ${accion.newState ? 'Activado' : 'Desactivado'}`);
                    break;
                case 'lock': // NUEVO: Rehacer bloqueo
                    if (obj) {
                        obj.userData.isLocked = accion.newState;
                        actualizarLista();
                        if (objetoSeleccionado === obj) {
                            if (obj.userData.isLocked) {
                                eliminarGizmos();
                            } else {
                                crearGizmos(obj);
                            }
                        }
                        mostrarToast(`‚Ü™ Rehaciendo: ${obj.name} ${obj.userData.isLocked ? 'bloqueado' : 'desbloqueado'}`);
                    }
                    break;
                case 'group': // NUEVO: Rehacer agrupar
                    if (accion.groupData) {
                        const newGroup = deserializarObjeto(accion.groupData);
                        escena.add(newGroup);
                        objetos.push(newGroup);

                        accion.childUuids.forEach(childUuid => {
                            const childObj = escena.getObjectByProperty('uuid', childUuid);
                            if (childObj) {
                                newGroup.attach(childObj);
                                // Asegurarse de que el hijo no est√© duplicado en la lista principal de objetos
                                const idx = objetos.indexOf(childObj);
                                if (idx > -1) objetos.splice(idx, 1);
                            }
                        });
                        seleccionarFigura(newGroup);
                        actualizarLista();
                        mostrarToast(`‚Ü™ Rehaciendo: Agrupar ${newGroup.name}`);
                    }
                    break;
                case 'ungroup': // NUEVO: Rehacer desagrupar
                    if (obj) { // obj es el objeto original (el grupo se elimina al desagrupar)
                        // No hay un objeto con el UUID del grupo original despu√©s de desagrupar,
                        // por lo que deserializamos el grupo completo y lo re-ensamblamos
                        const oldGroup = deserializarObjeto(accion.oldGroupData);
                        escena.remove(oldGroup); // Se elimina el grupo, pero los hijos quedan
                        // Eliminar los hijos de la escena si existen (solo si estaban en el grupo)
                        accion.childUuids.forEach(childUuid => {
                            const childObj = escena.getObjectByProperty('uuid', childUuid);
                            if (childObj) {
                                oldGroup.remove(childObj); // Desadjuntar del grupo temporal
                                escena.add(childObj); // Volver a a√±adir a la escena
                                objetos.push(childObj); // Volver a a√±adir a la lista de objetos
                            }
                        });
                        objetoSeleccionado = null;
                        eliminarGizmos();
                        ocultarColorPicker();
                        actualizarLista();
                        mostrarToast(`‚Ü™ Rehaciendo: Desagrupar ${oldGroup.name}`);
                    }
                    break;
                case 'lightIntensity': // Rehacer intensidad de luz de punto
                    if (obj && obj.userData.tipo === 'luzPunto' && accion.newIntensity !== undefined) {
                        obj.intensity = accion.newIntensity;
                        if (objetoSeleccionado === obj) {
                            pointLightIntensitySlider.value = obj.intensity;
                            pointLightIntensityLabel.textContent = obj.intensity.toFixed(1);
                        }
                        mostrarToast(`‚Ü™ Rehaciendo: Intensidad de luz ${obj.name}`);
                    }
                    break;
                case 'lightDistance': // Rehacer distancia de luz de punto
                    if (obj && obj.userData.tipo === 'luzPunto' && accion.newDistance !== undefined) {
                        obj.distance = accion.newDistance;
                        if (objetoSeleccionado === obj) {
                            pointLightDistanceSlider.value = obj.distance;
                            pointLightDistanceLabel.textContent = obj.distance.toFixed(1) + (obj.distance === 0 ? " (infinita)" : "");
                        }
                        mostrarToast(`‚Ü™ Rehaciendo: Distancia de luz ${obj.name}`);
                    }
                    break;
                case 'lightColor': // Rehacer color de luz de punto
                    if (obj && obj.userData.tipo === 'luzPunto' && accion.newColor !== undefined) {
                        obj.color.set(accion.newColor);
                        if (objetoSeleccionado === obj) {
                            pointLightColorPicker.value = "#" + obj.color.getHexString();
                             const helper = obj.children.find(c => c.name.startsWith(`Helper `));
                            if (helper && helper.material) {
                                helper.material.color.set(obj.color);
                            }
                        }
                        mostrarToast(`‚Ü™ Rehaciendo: Color de luz ${obj.name}`);
                    }
                    break;
            }
            actualizarBotonesUndoRedo();
        }

        function actualizarBotonesUndoRedo() {
            document.getElementById('btnDeshacer').disabled = indiceHistorial < 0;
            document.getElementById('btnRehacer').disabled = indiceHistorial >= historial.length - 1;
        }
        actualizarBotonesUndoRedo();

        // --- Guardar/Cargar Escena ---

        function serializarObjeto(obj) {
            const data = {
                uuid: obj.uuid,
                name: obj.name,
                type: obj.userData.tipo,
                position: obj.position.toArray(),
                rotation: obj.rotation.toArray(),
                scale: obj.scale.toArray(),
                isLocked: obj.userData.isLocked || false, // NUEVO: Guardar estado de bloqueo
                keyframes: keyframes.has(obj.uuid) ? keyframes.get(obj.uuid).map(v => ({ position: v.position.toArray(), rotation: v.rotation.toArray(), scale: v.scale.toArray() })) : []
            };

            if (obj.userData.tipo === 'luzPunto') {
                data.lightColor = obj.color.getHex();
                data.lightIntensity = obj.intensity;
                data.lightDistance = obj.distance;
            } else if (obj.material) {
                data.materialData = serializarMaterial(obj.material);
                data.textureURL = obj.userData.textureURL || null;
            }

            // Si es un modelo GLTF, guardar sus animaciones (metadata, no la data binaria completa)
            if (obj.userData.gltfAnimations) {
                data.gltfAnimations = obj.userData.gltfAnimations.map(anim => anim.name);
            }
            
            // Si es un grupo, guardar los UUIDs de sus hijos
            if (obj.userData.tipo === 'grupo' && obj.children.length > 0) {
                data.childrenUuids = obj.children.map(child => child.uuid);
            }

            return data;
        }

        function deserializarObjeto(data) {
            let obj;
            // La deserializaci√≥n de modelos GLTF/GLB por URL sigue siendo un desaf√≠o para localStorage
            // Aqu√≠, creamos un placeholder o nos basamos en tipos de geometr√≠a simple
            if (data.type === 'modelo') {
                obj = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), new THREE.MeshStandardMaterial({ color: 0x888888 }));
                obj.name = data.name + " (Placeholder)";
            } else if (data.type === 'luzPunto') {
                obj = new THREE.PointLight(data.lightColor, data.lightIntensity, data.lightDistance);
                // Recrear el helper visual
                const sphereSize = 0.2;
                const pointLightHelper = new THREE.Mesh(
                    new THREE.SphereGeometry(sphereSize, 16, 16),
                    new THREE.MeshBasicMaterial({ color: obj.color, transparent: true, opacity: 0.5 })
                );
                pointLightHelper.name = "Helper " + data.name.split(' ')[2]; // Asume el nombre "Luz de Punto X"
                obj.add(pointLightHelper);
            } else if (data.type === 'grupo') { // NUEVO: Deserializar grupos
                obj = new THREE.Group();
            }
            else {
                let geo;
                switch (data.type) {
                    case 'cubo': geo = new THREE.BoxGeometry(1, 1, 1); break;
                    case 'esfera': geo = new THREE.SphereGeometry(0.6, 32, 16); break;
                    case 'cono': geo = new THREE.ConeGeometry(0.5, 1.2, 32); break;
                    case 'cilindro': geo = new THREE.CylinderGeometry(0.5, 0.5, 1.2, 32); break;
                    default: geo = new THREE.BoxGeometry(1, 1, 1); break;
                }
                obj = new THREE.Mesh(geo, deserializarMaterial(data.materialData));
            }

            obj.uuid = data.uuid;
            obj.name = data.name;
            obj.position.fromArray(data.position);
            obj.rotation.fromArray(data.rotation);
            obj.scale.fromArray(data.scale);
            obj.userData.tipo = data.type;
            obj.userData.isLocked = data.isLocked || false; // Cargar estado de bloqueo
            obj.userData.lastColor = data.materialData ? data.materialData.color : undefined;
            obj.userData.textureURL = data.textureURL;
            obj.userData.gltfAnimations = data.gltfAnimations || null;

            // Cargar keyframes
            if (data.keyframes && data.keyframes.length > 0) {
                keyframes.set(obj.uuid, data.keyframes.map(k => ({
                    position: new THREE.Vector3().fromArray(k.position),
                    rotation: new THREE.Euler().fromArray(k.rotation),
                    scale: new THREE.Vector3().fromArray(k.scale)
                })));
            }

            // Cargar datos de luz de punto
            if (data.type === 'luzPunto') {
                obj.intensity = data.lightIntensity;
                obj.distance = data.lightDistance;
                obj.color.set(data.lightColor);
            }
            
            // Si es un grupo, no tiene material ni textura, y sus hijos se a√±adir√°n despu√©s
            if (data.type === 'grupo' && data.childrenUuids) {
                obj.userData.childrenUuids = data.childrenUuids; // Guardar para re-ensamblar despu√©s
            } else { // Para objetos normales, almacenar material original
                obj.userData.originalMaterial = obj.material;
                obj.userData.originalMaterialColor = obj.material.color ? obj.material.color.getHex() : 0xffffff;
            }

            return obj;
        }

        function guardarEscena() {
            const data = {
                objetos: objetos.map(obj => serializarObjeto(obj)),
                camaraPos: camara.position.toArray(),
                camaraTarget: controls.target.toArray(),
                riggingModeActivo: riggingModeActivo,
                ambientLightIntensity: ambientLight.intensity,
                ambientLightColor: ambientLight.color.getHex(),
                skyboxActive: skyboxActivo,
                animationSpeed: duracionPorFrame,
                modoVisualizacion: modoVisualizacion // NUEVO: Guardar modo de visualizaci√≥n
            };
            try {
                localStorage.setItem('infinity3d_scene', JSON.stringify(data));
                mostrarToast("üíæ Escena guardada exitosamente.");
            } catch (e) {
                mostrarToast("‚ùå Error al guardar escena: " + e.message);
                console.error("Error al guardar escena:", e);
            }
        }

        function cargarEscena() {
            mostrarDialogoConfirmacion('cargar');
        }

        function confirmarCargarEscena() {
            try {
                const dataString = localStorage.getItem('infinity3d_scene');
                if (!dataString) {
                    mostrarToast("üìÇ No hay escenas guardadas.");
                    return;
                }
                reiniciarEscenaSinConfirmacion();

                const data = JSON.parse(dataString);
                
                // Primero deserializar todos los objetos sin adjuntar hijos a grupos
                const deserializedObjectsMap = new Map(); // Para un acceso r√°pido por UUID
                data.objetos.forEach(objData => {
                    const obj = deserializarObjeto(objData);
                    escena.add(obj);
                    objetos.push(obj);
                    deserializedObjectsMap.set(obj.uuid, obj);

                    const tipo = obj.userData.tipo;
                    const match = obj.name.match(/\s(\d+)$/);
                    if (match) {
                        const num = parseInt(match[1]);
                        if (contador[tipo] < num) {
                            contador[tipo] = num;
                        }
                    }
                });

                // Luego, re-ensamblar los grupos adjuntando sus hijos
                objetos.forEach(obj => {
                    if (obj.userData.tipo === 'grupo' && obj.userData.childrenUuids) {
                        obj.userData.childrenUuids.forEach(childUuid => {
                            const child = deserializedObjectsMap.get(childUuid);
                            if (child) {
                                obj.attach(child); // Adjuntar el hijo al grupo
                                // Eliminar el hijo del array de objetos principales si ya est√° en el grupo
                                const index = objetos.indexOf(child);
                                if (index > -1) {
                                    objetos.splice(index, 1);
                                }
                            }
                        });
                    }
                });


                actualizarLista();

                if (data.camaraPos && data.camaraTarget) {
                    camara.position.fromArray(data.camaraPos);
                    controls.target.fromArray(data.camaraTarget);
                    controls.update();
                }

                if (data.riggingModeActivo !== undefined) {
                    riggingModeCheckbox.checked = data.riggingModeActivo;
                    toggleRiggingMode(data.riggingModeActivo);
                }

                if (data.ambientLightIntensity !== undefined) {
                    ambientLight.intensity = data.ambientLightIntensity;
                    ambientLightIntensitySlider.value = data.ambientLightIntensity;
                    ambientLightIntensityLabel.textContent = data.ambientLightIntensity.toFixed(2);
                }
                if (data.ambientLightColor !== undefined) {
                    ambientLight.color.set(data.ambientLightColor);
                    ambientLightColorPicker.value = "#" + new THREE.Color(data.ambientLightColor).getHexString();
                }

                if (data.skyboxActive !== undefined) {
                    skyboxCheckbox.checked = data.skyboxActive;
                    toggleSkybox(data.skyboxActive);
                } else {
                     skyboxCheckbox.checked = true;
                     toggleSkybox(true);
                }
                
                if (data.animationSpeed !== undefined) {
                    duracionPorFrame = data.animationSpeed;
                    animSpeedSlider.value = data.animationSpeed;
                    animSpeedLabel.textContent = `${data.animationSpeed} ms/frame`;
                }

                // NUEVO: Cargar modo de visualizaci√≥n
                if (data.modoVisualizacion !== undefined) {
                    establecerModoVisualizacion(data.modoVisualizacion);
                } else {
                    establecerModoVisualizacion('normal'); // Por defecto si no est√° guardado
                }

                mostrarToast("‚úÖ Escena cargada exitosamente.");
                historial.length = 0;
                indiceHistorial = -1;
                actualizarBotonesUndoRedo();
            } catch (e) {
                mostrarToast("‚ùå Error al cargar escena. Datos corruptos.");
                console.error("Error al cargar escena:", e);
            }
        }

        function reiniciarEscena() {
            mostrarDialogoConfirmacion('reiniciar');
        }

        function reiniciarEscenaSinConfirmacion() {
            while(objetos.length > 0){
                const obj = objetos.pop();
                escena.remove(obj);
                // Limpiar bboxHelper si existe
                if (obj.userData.bboxHelper) {
                    escena.remove(obj.userData.bboxHelper);
                    obj.userData.bboxHelper.dispose();
                    obj.userData.bboxHelper = null;
                }
            }
            for (const key in contador) {
                contador[key] = 0;
            }
            objetoSeleccionado = null;
            eliminarGizmos();
            ocultarColorPicker();
            actualizarLista();
            keyframes.clear();
            animando = false;
            camara.position.set(0, 4, 8);
            controls.target.set(0, 1, 0);
            controls.update();
            historial.length = 0;
            indiceHistorial = -1;
            actualizarBotonesUndoRedo();
            riggingModeCheckbox.checked = false;
            toggleRiggingMode(false);
            
            // Restablecer valores de configuraci√≥n a los predeterminados de la UI
            ambientLight.intensity = parseFloat(ambientLightIntensitySlider.value);
            ambientLightIntensityLabel.textContent = ambientLight.intensity.toFixed(2);
            ambientLight.color.set(0xffffff);
            ambientLightColorPicker.value = "#ffffff";

            // Restablecer valores de luz de punto
            pointLightIntensitySlider.value = 1;
            pointLightIntensityLabel.textContent = "1.0";
            pointLightDistanceSlider.value = 0;
            pointLightDistanceLabel.textContent = "0.0 (infinita)";
            pointLightColorPicker.value = "#ffffff";

            skyboxCheckbox.checked = true;
            toggleSkybox(true);

            duracionPorFrame = parseInt(animSpeedSlider.value);
            animSpeedLabel.textContent = `${duracionPorFrame} ms/frame`;

            establecerModoVisualizacion('normal'); // Restablecer modo de visualizaci√≥n

            mostrarToast("üÜï Nueva escena creada.");
        }


        // --- Animaci√≥n ---

        const keyframes = new Map();
        let animando = false, frameActual = 0, totalFrames = 0;

        function agregarFrame() {
            if (!objetoSeleccionado) {
                mostrarToast("‚òùÔ∏è Selecciona una figura para a√±adir un fotograma.");
                return;
            }
            if (riggingModeActivo) {
                mostrarToast("üö´ No se pueden agregar fotogramas en Rigging Mode.");
                return;
            }
            if (objetoSeleccionado.userData.isLocked) {
                mostrarToast("üîí Objeto bloqueado. Desbloqu√©alo para agregar fotogramas.");
                return;
            }
            if (objetoSeleccionado.userData.tipo === 'luzPunto' || objetoSeleccionado.userData.tipo === 'grupo') {
                mostrarToast("üö´ Las luces y los grupos no pueden tener fotogramas clave directamente.");
                return;
            }

            const id = objetoSeleccionado.uuid;
            if (!keyframes.has(id)) keyframes.set(id, []);

            keyframes.get(id).push({
                position: objetoSeleccionado.position.clone(),
                rotation: objetoSeleccionado.rotation.clone(),
                scale: objetoSeleccionado.scale.clone()
            });
            mostrarToast(`‚úîÔ∏è Fotograma ${keyframes.get(id).length} agregado para ${objetoSeleccionado.name}.`);
        }

        function reproducirAnimacion() {
            if (!objetoSeleccionado) {
                mostrarToast("‚òùÔ∏è Selecciona una figura para animar.");
                return;
            }
            if (riggingModeActivo) {
                mostrarToast("üö´ No se puede animar en Rigging Mode.");
                return;
            }
            if (objetoSeleccionado.userData.tipo === 'luzPunto' || objetoSeleccionado.userData.tipo === 'grupo') {
                mostrarToast("üö´ Las luces y los grupos no pueden animarse directamente.");
                return;
            }
            const id = objetoSeleccionado.uuid;
            const frames = keyframes.get(id);
            if (!frames || frames.length < 2) {
                mostrarToast("‚ö†Ô∏è Necesitas al menos 2 fotogramas para animar.");
                return;
            }
            frameActual = 0;
            totalFrames = frames.length;
            animando = true;
            mostrarToast(`‚ñ∂ Animando ${objetoSeleccionado.name}...`);
            animarFrame(id);
        }

        function animarFrame(id) {
            if (!animando) return;

            const frames = keyframes.get(id);
            if (!frames || frames.length === 0) {
                animando = false;
                return;
            }

            const actualFrameIndex = frameActual % frames.length;
            const nextFrameIndex = (frameActual + 1) % frames.length;

            const actualState = frames[actualFrameIndex];
            const nextState = frames[nextFrameIndex];

            let progreso = 0;
            const inicio = performance.now();

            function paso(t) {
                if (!animando) return;

                progreso = (t - inicio) / duracionPorFrame;
                if (progreso >= 1) {
                    objetoSeleccionado.position.copy(nextState.position);
                    objetoSeleccionado.rotation.copy(nextState.rotation);
                    objetoSeleccionado.scale.copy(nextState.scale);

                    frameActual++;
                    if (frameActual >= totalFrames) {
                        animando = false;
                        mostrarToast("‚è∏ Animaci√≥n finalizada.");
                        return;
                    }
                    setTimeout(() => animarFrame(id), 50);
                    return;
                }

                objetoSeleccionado.position.lerpVectors(actualState.position, nextState.position, progreso);
                objetoSeleccionado.scale.lerpVectors(actualState.scale, nextState.scale, progreso);

                const q1 = new THREE.Quaternion().setFromEuler(actualState.rotation);
                const q2 = new THREE.Quaternion().setFromEuler(nextState.rotation);
                objetoSeleccionado.quaternion.slerpQuaternions(q1, q2, progreso);
                objetoSeleccionado.rotation.setFromQuaternion(objetoSeleccionado.quaternion);

                if (objetoSeleccionado && objetoSeleccionado.uuid === id) {
                    if (modoTransformacion === 'trasladar' || modoTransformacion === 'rotar') {
                        gizmos.forEach(g => {
                            if (!g.parent || g.parent.uuid !== objetoSeleccionado.uuid) {
                                g.position.copy(objetoSeleccionado.position);
                            }
                        });
                    }
                }
                requestAnimationFrame(paso);
            }
            requestAnimationFrame(paso);
        }

        // --- Exportar Video ---

        function exportarVideo() {
            if (!window.MediaRecorder) {
                mostrarToast("‚ùå Tu navegador no soporta la grabaci√≥n de video.");
                return;
            }
            if (!objetoSeleccionado || !keyframes.has(objetoSeleccionado.uuid) || keyframes.get(objetoSeleccionado.uuid).length < 2) {
                mostrarToast("‚ö†Ô∏è Necesitas una figura con al menos 2 fotogramas para exportar.");
                return;
            }
            if (riggingModeActivo) {
                mostrarToast("üö´ No se puede exportar video en Rigging Mode.");
                return;
            }
            if (objetoSeleccionado.userData.isLocked) {
                mostrarToast("üîí Objeto bloqueado. Desbloqu√©alo para exportar video.");
                return;
            }
            if (objetoSeleccionado.userData.tipo === 'luzPunto' || objetoSeleccionado.userData.tipo === 'grupo') {
                mostrarToast("üö´ Las luces y los grupos no pueden exportarse como video de animaci√≥n directamente.");
                return;
            }

            const stream = render.domElement.captureStream(30);
            const grabador = new MediaRecorder(stream);
            const partes = [];

            grabador.ondataavailable = e => partes.push(e.data);
            grabador.onstop = () => {
                const blob = new Blob(partes, { type: "video/webm" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = "Infinity3D_Animacion.webm";
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                mostrarToast("‚úÖ Video exportado.");
            };

            reproducirAnimacion();
            if (animando) {
                grabador.start();
                mostrarToast("üé• Grabando animaci√≥n...");
                const duracionTotalAnimacion = (totalFrames - 1) * duracionPorFrame;

                setTimeout(() => {
                    if (grabador.state !== "inactive") {
                        grabador.stop();
                    }
                }, duracionTotalAnimacion + 500);
            } else {
                 mostrarToast("‚ö†Ô∏è La animaci√≥n no pudo comenzar para grabar.");
            }
        }

        function exportarImagen() {
            try {
                render.render(escena, camara);
                const imageDataURL = render.domElement.toDataURL('image/png');
                
                const a = document.createElement('a');
                a.href = imageDataURL;
                a.download = 'Infinity3D_Captura.png';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                mostrarToast("üñºÔ∏è Imagen exportada.");
            } catch (e) {
                mostrarToast("‚ùå Error al exportar imagen.");
                console.error("Error al exportar imagen:", e);
            }
        }


        // --- Pantalla Completa ---
        function activarPantallaCompleta() {
            const elem = document.documentElement;
            if (elem.requestFullscreen) {
                elem.requestFullscreen();
            } else if (elem.webkitRequestFullscreen) {
                elem.webkitRequestFullscreen();
            }
            mostrarToast("‚õ∂ Modo Pantalla Completa");
        }

        // --- Di√°logos de Confirmaci√≥n ---
        function mostrarDialogoConfirmacion(accion, obj = null) {
            accionConfirmacion = { type: accion, obj: obj };
            dialogoConfirmacion.style.display = 'flex';

            switch (accion) {
                case 'reiniciar':
                    dialogoTitulo.textContent = 'Reiniciar Escena';
                    dialogoMensaje.textContent = '¬øNueva escena? ¬°Se perder√°n los cambios no guardados!';
                    break;
                case 'cargar':
                    dialogoTitulo.textContent = 'Cargar Escena';
                    dialogoMensaje.textContent = '¬øCargar escena guardada? ¬°La actual se perder√°!';
                    break;
                case 'eliminar':
                    dialogoTitulo.textContent = 'Eliminar Figura';
                    dialogoMensaje.textContent = `¬øEliminar ${obj.name}? ¬°No se puede deshacer!`;
                    break;
            }
        }

        btnDialogoSi.onclick = () => {
            dialogoConfirmacion.style.display = 'none';
            if (accionConfirmacion) {
                switch (accionConfirmacion.type) {
                    case 'reiniciar':
                        reiniciarEscenaSinConfirmacion();
                        break;
                    case 'cargar':
                        confirmarCargarEscena();
                        break;
                    case 'eliminar':
                        confirmarEliminar(accionConfirmacion.obj);
                        break;
                }
                accionConfirmacion = null;
            }
        };

        btnDialogoNo.onclick = () => {
            dialogoConfirmacion.style.display = 'none';
            accionConfirmacion = null;
            mostrarToast("üö´ Acci√≥n cancelada.");
        };

        // --- Bucle de Renderizado ---
        function bucle() {
            requestAnimationFrame(bucle);
            controls.update();
            // Actualizar bbox helpers si el modo es 'bbox'
            if (modoVisualizacion === 'bbox') {
                objetos.forEach(obj => {
                    if (obj.userData.bboxHelper) {
                        obj.userData.bboxHelper.update();
                    }
                });
            }
            render.render(escena, camara);
        }

        bucle();
    </script>
</body>
</html>
